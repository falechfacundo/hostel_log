"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/hooks/useTravelers.js":
/*!***********************************!*\
  !*** ./src/hooks/useTravelers.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   partnerKeys: function() { return /* binding */ partnerKeys; },\n/* harmony export */   selectedPartnerKey: function() { return /* binding */ selectedPartnerKey; },\n/* harmony export */   travelerKeys: function() { return /* binding */ travelerKeys; },\n/* harmony export */   useTravelers: function() { return /* binding */ useTravelers; }\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useMutation.js\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.js\");\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var _barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=format!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/queryClient */ \"(app-pages-browser)/./src/lib/queryClient.js\");\n/* harmony import */ var _store_partnerStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/store/partnerStore */ \"(app-pages-browser)/./src/store/partnerStore.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _hooks_useHostelAssignments__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/hooks/useHostelAssignments */ \"(app-pages-browser)/./src/hooks/useHostelAssignments.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst selectedPartnerKey = \"selectedPartner\";\n// Query keys para travelers\nconst travelerKeys = {\n    all: [\n        \"travelers\"\n    ],\n    lists: ()=>[\n            ...travelerKeys.all,\n            \"list\"\n        ],\n    list: (filters)=>[\n            ...travelerKeys.lists(),\n            {\n                filters\n            }\n        ],\n    details: ()=>[\n            ...travelerKeys.all,\n            \"detail\"\n        ],\n    detail: (id)=>[\n            ...travelerKeys.details(),\n            id\n        ],\n    // Específico por fecha y partner\n    byDateAndPartner: (date, partnerId)=>[\n            ...travelerKeys.lists(),\n            {\n                date,\n                partnerId\n            }\n        ],\n    // Specific keys for types\n    individuals: {\n        all: [\n            \"individuals\"\n        ],\n        lists: ()=>[\n                ...travelerKeys.individuals.all,\n                \"list\"\n            ],\n        list: (filters)=>[\n                ...travelerKeys.individuals.lists(),\n                {\n                    filters\n                }\n            ],\n        detail: (id)=>[\n                ...travelerKeys.individuals.all,\n                \"detail\",\n                id\n            ]\n    },\n    groups: {\n        all: [\n            \"groups\"\n        ],\n        lists: ()=>[\n                ...travelerKeys.groups.all,\n                \"list\"\n            ],\n        list: (filters)=>[\n                ...travelerKeys.groups.lists(),\n                {\n                    filters\n                }\n            ],\n        detail: (id)=>[\n                ...travelerKeys.groups.all,\n                \"detail\",\n                id\n            ]\n    }\n};\n// Clave para partners\nconst partnerKeys = {\n    all: [\n        \"partners\"\n    ],\n    lists: ()=>[\n            ...partnerKeys.all,\n            \"list\"\n        ],\n    list: (filters)=>[\n            ...partnerKeys.lists(),\n            {\n                filters\n            }\n        ],\n    byDate: (date)=>[\n            ...partnerKeys.lists(),\n            {\n                date\n            }\n        ],\n    details: ()=>[\n            ...partnerKeys.all,\n            \"detail\"\n        ],\n    detail: (id)=>[\n            ...partnerKeys.details(),\n            id\n        ],\n    assignments: ()=>[\n            ...partnerKeys.all,\n            \"assignments\"\n        ],\n    assignmentsByDate: (date)=>[\n            ...partnerKeys.assignments(),\n            {\n                date\n            }\n        ]\n};\n// Función para obtener partners según la fecha\nconst fetchPartnersByDate = async (date)=>{\n    const dateStr = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(new Date(date), \"yyyy-MM-dd\");\n    try {\n        // Modificamos la consulta para obtener partners donde la fecha seleccionada esté dentro del rango\n        const { data: partners, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"partners\").select(\"*\").lte(\"start_date\", dateStr) // start_date <= selectedDate\n        .gte(\"end_date\", dateStr) // end_date >= selectedDate\n        .order(\"name\");\n        if (error) throw error;\n        // If no partners found, return empty array\n        if (!partners || partners.length === 0) {\n            return [];\n        }\n        // For each partner, fetch its groups and individuals\n        const partnersWithRelatedData = await Promise.all(partners.map(async (partner)=>{\n            try {\n                // Fetch groups for this partner\n                const groups = await fetchGroups(partner.id);\n                // Fetch individuals for this partner\n                const individuals = await fetchIndividuals(partner.id);\n                const hostelAssignments = await fetchHostelAssignments(partner.id);\n                // Return partner with its related data\n                return {\n                    ...partner,\n                    groups,\n                    individuals,\n                    hostelAssignments\n                };\n            } catch (err) {\n                console.error(\"Error fetching related data for partner \".concat(partner.id, \":\"), err);\n                // Return partner with empty related data\n                return {\n                    ...partner,\n                    groups: [],\n                    individuals: []\n                };\n            }\n        }));\n        return partnersWithRelatedData;\n    } catch (error) {\n        console.error(\"Error fetching partners:\", error);\n        return [];\n    }\n};\n// Fetch all individuals (persons without a group)\nconst fetchIndividuals = async (partnerId)=>{\n    if (!partnerId) {\n        console.log(\"No partner ID provided for fetching individuals, returning empty array\");\n        return [];\n    }\n    // Extract ID if partnerId is an object\n    const actualPartnerId = typeof partnerId === \"object\" && partnerId !== null ? partnerId.id || null : partnerId;\n    // Only proceed with the query if we have a valid partner ID\n    if (!actualPartnerId) {\n        console.log(\"Invalid partner ID, returning empty array\");\n        return [];\n    }\n    try {\n        let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"person\").select(\"*\").is(\"group_id\", null).eq(\"partner_id\", actualPartnerId).order(\"name\");\n        const { data, error } = await query;\n        if (error) throw error;\n        return data || [];\n    } catch (error) {\n        console.error(\"Error fetching individuals:\", error);\n        return [];\n    }\n};\n// Fetch all groups with their people\nconst fetchGroups = async (partnerId)=>{\n    if (!partnerId) {\n        console.log(\"No partner ID provided for fetching groups, returning empty array\");\n        return [];\n    }\n    // Extract ID if partnerId is an object\n    const actualPartnerId = typeof partnerId === \"object\" && partnerId !== null ? partnerId.id || null : partnerId;\n    // Only proceed with the query if we have a valid partner ID\n    if (!actualPartnerId) {\n        console.log(\"Invalid partner ID, returning empty array\");\n        return [];\n    }\n    try {\n        let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"groups\").select(\"\\n        *,\\n        person(*)\\n      \").eq(\"partner_id\", actualPartnerId);\n        const { data, error } = await query;\n        if (error) throw error;\n        // Format data to match the original structure\n        return data.map((group)=>({\n                ...group,\n                people: group.person || []\n            }));\n    } catch (error) {\n        console.error(\"Error fetching groups:\", error);\n        return [];\n    }\n};\n// Fetch hostel assignments for a specific partner\nconst fetchHostelAssignments = async (partnerId)=>{\n    if (!partnerId) {\n        console.log(\"No partner ID provided for fetching hostel assignments, returning empty array\");\n        return [];\n    }\n    // Extract ID if partnerId is an object\n    const actualPartnerId = typeof partnerId === \"object\" && partnerId !== null ? partnerId.id || null : partnerId;\n    // Only proceed with the query if we have a valid partner ID\n    if (!actualPartnerId) {\n        console.log(\"Invalid partner ID for hostel assignments, returning empty array\");\n        return [];\n    }\n    try {\n        // Check if we already have cached data in the query client\n        const cachedData = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(_hooks_useHostelAssignments__WEBPACK_IMPORTED_MODULE_5__.hostelAssignmentKeys.byPartnerId(actualPartnerId));\n        if (cachedData) {\n            console.log(\"Using cached hostel assignments\");\n            return cachedData;\n        }\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"hostel_partner_assignments\").select(\"\\n        *,\\n        hostel:hostels(*)\\n      \").eq(\"partner_id\", actualPartnerId);\n        if (error) throw error;\n        // Store the result in the query cache\n        _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(_hooks_useHostelAssignments__WEBPACK_IMPORTED_MODULE_5__.hostelAssignmentKeys.byPartnerId(actualPartnerId), data || []);\n        return data || [];\n    } catch (error) {\n        console.error(\"Error fetching hostel assignments:\", error);\n        return [];\n    }\n};\n// Create a new partner\nconst createPartner = async (partnerData)=>{\n    const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"partners\").insert([\n        {\n            name: partnerData.name,\n            size: partnerData.size || 0,\n            days: partnerData.days || 5,\n            start_date: partnerData.start_date || (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(new Date(), \"yyyy-MM-dd\"),\n            end_date: partnerData.end_date || (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(new Date(), \"yyyy-MM-dd\")\n        }\n    ]).select().single();\n    if (error) throw error;\n    return data;\n};\n// Delete a partner\nconst deletePartner = async (id)=>{\n    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"partners\").delete().eq(\"id\", id);\n    if (error) throw error;\n    return {\n        id\n    };\n};\n// Pre-initialize the cache for selectedPartnerKey to prevent undefined issues\n// This ensures the cache always has a value, even if it's null\nif (_lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(selectedPartnerKey) === undefined) {\n    _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(selectedPartnerKey, null);\n}\n// Hook combinado para manejar partners y travelers\nfunction useTravelers() {\n    let initialDate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Date();\n    _s();\n    // Estado para la fecha actual - usamos el formato string para queries\n    const dateStr = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(initialDate, \"yyyy-MM-dd\");\n    // Use ref for tracking render count to help debug excessive renders\n    const renderCountRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(0);\n    renderCountRef.current++;\n    const { partners: storePartners, individuals: storeIndividuals, groups: storeGroups, addGroup: storeAddGroup, removeGroup: storeRemoveGroup, updateGroup: storeUpdateGroup, addIndividual: storeAddIndividual, removeIndividual: storeRemoveIndividual, updateIndividual: storeUpdateIndividual, hostelAssignments: storeHostelAssignments } = (0,_store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore)();\n    const selectedPartner = (0,_store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore)((state)=>state.selectedPartner);\n    const setSelectedPartner = (0,_store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore)((state)=>state.setSelectedPartner);\n    // const partners = usePartnerStore((state) => state.partners);\n    const setPartners = (0,_store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore)((state)=>state.setPartners);\n    // const individuals = usePartnerStore((state) => state.individuals);\n    // const groups = usePartnerStore((state) => state.groups);\n    const setGroups = (0,_store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore)((state)=>state.setGroups);\n    const setIndividuals = (0,_store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore)((state)=>state.setIndividuals);\n    // const addGroup = usePartnerStore((state) => state.addGroup);\n    // const removeGroup = usePartnerStore((state) => state.removeGroup);\n    // const updateGroup = usePartnerStore((state) => state.updateGroup);\n    // const addIndividual = usePartnerStore((state) => state.addIndividual);\n    // const removeIndividual = usePartnerStore((state) => state.removeIndividual);\n    // const updateIndividual = usePartnerStore((state) => state.updateIndividual);\n    // const hostelAssignments = usePartnerStore((state) => state.hostelAssignments);\n    const setHostelAssignments = (0,_store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore)((state)=>state.setHostelAssignments);\n    // This is the first query that runs when the app loads\n    const { data: partners = [], isLoading: isLoadingPartners, error: partnersError, refetch: refetchPartnersQuery } = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__.useQuery)({\n        queryKey: partnerKeys.byDate(dateStr),\n        queryFn: ()=>fetchPartnersByDate(initialDate),\n        staleTime: 60000,\n        onSuccess: (data)=>{\n            // Sync fetched partners with our store\n            setPartners(data);\n            // If we have a selected partner, update its groups and individuals in the store\n            if (selectedPartner === null || selectedPartner === void 0 ? void 0 : selectedPartner.id) {\n                const currentPartner = data.find((p)=>p.id === selectedPartner.id);\n                if (currentPartner) {\n                    // Update groups and individuals for the selected partner\n                    if (currentPartner.groups) setGroups(currentPartner.groups);\n                    if (currentPartner.individuals) setIndividuals(currentPartner.individuals);\n                    // Add this line to update hostelAssignments in the store\n                    if (currentPartner.hostelAssignments) setHostelAssignments(currentPartner.hostelAssignments);\n                }\n            }\n        }\n    });\n    // Replace the selectPartner function to use our store\n    const selectPartner = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((partner)=>{\n        return setSelectedPartner(partner);\n    }, [\n        setSelectedPartner\n    ]);\n    // Auto-select first partner only if needed and available\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        if (partners.length > 0 && !selectedPartner) {\n            // Use a small delay to avoid render cycles\n            const timeoutId = setTimeout(()=>{\n                selectPartner(partners[0]);\n                // Also update groups and individuals from the first partner\n                if (partners[0].groups) setGroups(partners[0].groups);\n                if (partners[0].individuals) setIndividuals(partners[0].individuals);\n                // Add this line to update hostelAssignments for the first partner\n                if (partners[0].hostelAssignments) setHostelAssignments(partners[0].hostelAssignments);\n            }, 50);\n            return ()=>clearTimeout(timeoutId);\n        }\n    }, [\n        partners.length,\n        selectedPartner,\n        selectPartner\n    ]);\n    // Mutations para partners\n    const createPartnerMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: createPartner,\n        onSuccess: async (newPartner)=>{\n            // Instead of manually adding to the array, we'll:\n            // 1. Prepare the new partner just for initial selection\n            const preparedPartner = {\n                ...newPartner,\n                groups: [],\n                individuals: [],\n                hostelAssignments: []\n            };\n            // 2. Invalidate the queries to force a fresh fetch\n            const dateStr = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(initialDate, \"yyyy-MM-dd\");\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: partnerKeys.byDate(dateStr),\n                refetchActive: true\n            });\n            // 3. Temporarily select the new partner for UI responsiveness\n            // but don't manually update the partners array\n            selectPartner(preparedPartner);\n            setGroups([]);\n            setIndividuals([]);\n            // 4. Explicitly refetch to ensure we have fresh data\n            await refetchPartnersQuery();\n        // Note: We're NOT manually updating the partners array anymore\n        // Instead letting the query refetch handle that\n        },\n        onError: (err)=>{\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Error al crear partner: \".concat(err.message));\n        }\n    });\n    const deletePartnerMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: deletePartner,\n        onMutate: async (id)=>{\n            // Cancel any outgoing refetches so they don't overwrite our optimistic update\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: partnerKeys.lists()\n            });\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: partnerKeys.detail(id)\n            });\n            // Snapshot the previous value\n            const previousPartners = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(partnerKeys.lists());\n            // Optimistically remove the partner from the cache\n            if (previousPartners) {\n                const updatedPartners = previousPartners.filter((p)=>p.id !== id);\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(partnerKeys.lists(), updatedPartners);\n                // Also update the store\n                setPartners(updatedPartners);\n                // If we're deleting the currently selected partner, reset selection\n                const currentSelectedPartner = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(selectedPartnerKey);\n                if (currentSelectedPartner && currentSelectedPartner.id === id) {\n                    // Select a different partner or set to null\n                    const newSelection = updatedPartners.length > 0 ? updatedPartners[0] : null;\n                    _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(selectedPartnerKey, newSelection);\n                    // Also update groups and individuals if needed\n                    if (newSelection) {\n                        if (newSelection.groups) setGroups(newSelection.groups);\n                        if (newSelection.individuals) setIndividuals(newSelection.individuals);\n                    } else {\n                        setGroups([]);\n                        setIndividuals([]);\n                    }\n                }\n            }\n            return {\n                previousPartners\n            };\n        },\n        onSuccess: (param)=>{\n            let { id } = param;\n            // Remove from cache completely\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.removeQueries({\n                queryKey: partnerKeys.detail(id)\n            });\n        },\n        onError: (err, id, context)=>{\n            sonner__WEBPACK_IMPORTED_MODULE_1__.toast.error(\"Error al eliminar partner: \".concat(err.message));\n            // Rollback to the previous state if we have it\n            if (context === null || context === void 0 ? void 0 : context.previousPartners) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(partnerKeys.lists(), context.previousPartners);\n            }\n        },\n        onSettled: ()=>{\n            // Always refetch after error or success to be sure we're in sync with the server\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: partnerKeys.lists()\n            });\n        }\n    });\n    // Función para refrescar los partners con una nueva fecha\n    const refetchPartners = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(async (date)=>{\n        if (date) {\n            const newDateStr = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(new Date(date), \"yyyy-MM-dd\");\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: partnerKeys.byDate(newDateStr)\n            });\n        } else {\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: partnerKeys.byDate(dateStr)\n            });\n        }\n        return await refetchPartnersQuery();\n    }, [\n        dateStr,\n        refetchPartnersQuery\n    ]);\n    // Incluir resto de operaciones sobre travelers del hook original\n    // Create a new individual\n    const createIndividual = async (individualData)=>{\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"person\").insert([\n            {\n                name: individualData.name,\n                backpack: individualData.backpack || false,\n                partner_id: individualData.partnerId\n            }\n        ]).select().single();\n        if (error) throw error;\n        return data;\n    };\n    // Create a new group with people in a single transaction\n    const createGroup = async (groupData)=>{\n        var _groupData_people;\n        // First create the group\n        const { partnerId } = groupData;\n        console.log(\"Creating group with partner ID:\", groupData);\n        const { data: newGroup, error: groupError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"groups\").insert([\n            {\n                size: ((_groupData_people = groupData.people) === null || _groupData_people === void 0 ? void 0 : _groupData_people.length) || 0,\n                partner_id: partnerId\n            }\n        ]).select().single();\n        if (groupError) throw groupError;\n        // If there are people, create them\n        if (groupData.people && groupData.people.length > 0) {\n            const peopleToInsert = groupData.people.map((person)=>({\n                    name: person.name,\n                    backpack: person.backpack || false,\n                    group_id: newGroup.id,\n                    partner_id: partnerId\n                }));\n            const { data: people, error: peopleError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"person\").insert(peopleToInsert).select();\n            if (peopleError) throw peopleError;\n            return {\n                ...newGroup,\n                people\n            };\n        }\n        return {\n            ...newGroup,\n            people: []\n        };\n    };\n    // Update an individual\n    const updateIndividual = async (param)=>{\n        let { id, data } = param;\n        const { data: updatedData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"person\").update({\n            name: data.name,\n            backpack: data.backpack\n        }).eq(\"id\", id).select().single();\n        if (error) throw error;\n        return updatedData;\n    };\n    // Update a group\n    const updateGroup = async (param)=>{\n        let { id, data } = param;\n        const { data: updatedGroup, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"groups\").update({\n            name: data.name,\n            size: data.size || 0\n        }).eq(\"id\", id).select().single();\n        if (error) throw error;\n        return updatedGroup;\n    };\n    const deleteGroup = async (id)=>{\n        // Primero, obtenemos los datos actuales del grupo para tener el contexto completo\n        const { data: groupToDelete, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"groups\").select(\"*\").eq(\"id\", id).single();\n        if (fetchError) throw fetchError;\n        // Eliminamos el grupo\n        const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"groups\").delete().eq(\"id\", id);\n        if (error) throw error;\n        // Retornamos el grupo completo para tener toda la información disponible\n        return groupToDelete;\n    };\n    // Delete an individual\n    const deleteIndividual = async (id)=>{\n        const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"person\").delete().eq(\"id\", id);\n        if (error) throw error;\n        return {\n            id\n        };\n    };\n    // Replace the addPersonToGroup function with this improved version\n    const addPersonToGroup = async (param)=>{\n        let { group, personData } = param;\n        console.log(\"Adding person to group with ID:\", group.id);\n        // Make sure we have the correct partner_id\n        const partnerId = (selectedPartner === null || selectedPartner === void 0 ? void 0 : selectedPartner.id) || group.partner_id;\n        // Add the person with complete data\n        const { data: newPerson, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"person\").insert([\n            {\n                name: personData.name,\n                group_id: group.id\n            }\n        ]).select();\n        if (error) throw error;\n        // Calculate the new size\n        const newSize = group.size + 1;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"groups\").update({\n                size: newSize,\n                updated_at: new Date()\n            }).eq(\"id\", group.id).select();\n            // Return complete data for UI update\n            return {\n                newPerson: newPerson[0],\n                groupId: group.id,\n                newGroupSize: newSize\n            };\n        } catch (err) {\n            console.warn(\"Error updating group size, but person was added:\", err);\n            // Return the person data so UI can still update\n            return {\n                newPerson: newPerson[0],\n                groupId: group.id,\n                newGroupSize: newSize\n            };\n        }\n    };\n    // Añadir la función de actualización de persona\n    const updatePerson = async (personData)=>{\n        const { id, ...updates } = personData;\n        console.log(\"Updating person backpack:\", updates.backpack);\n        const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"person\").update({\n            backpack: updates.backpack,\n            updated_at: new Date()\n        }).eq(\"id\", id);\n        if (error) throw error;\n        return data;\n    };\n    // Add this function after other database functions like addPersonToGroup\n    const removePersonFromGroup = async (param)=>{\n        let { groupId, personId } = param;\n        console.log(\"Removing person from group with ID:\", groupId);\n        // First, fetch the current group to get its size\n        const { data: group, error: groupError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"groups\").select(\"size, partner_id\").eq(\"id\", groupId).single();\n        if (groupError) throw groupError;\n        const { data: updatedPerson, error: personError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"person\").delete().eq(\"id\", personId);\n        // if (personError) throw personError;\n        // Calculate new size based on the fetched group size\n        const newSize = Math.max(0, ((group === null || group === void 0 ? void 0 : group.size) || 1) - 1);\n        const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"groups\").update({\n            size: newSize\n        }).eq(\"id\", groupId);\n        // if (updateError) throw updateError;\n        return {\n            updatedPerson,\n            groupId,\n            newGroupSize: newSize\n        };\n    };\n    // Derived loading and error states - updated to use only travelers query\n    const isLoading = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>isLoadingPartners, [\n        isLoadingPartners\n    ]);\n    // Add an individual - update store after success\n    const addIndividualMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: createIndividual,\n        onSuccess: (newIndividual)=>{\n            // Update cache with new individual to avoid refetching\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.individuals.lists(), function() {\n                let oldData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n                return [\n                    ...oldData,\n                    newIndividual\n                ];\n            });\n            // Also update our Zustand store\n            storeAddIndividual(newIndividual);\n        },\n        onError: (err)=>{},\n        onSettled: ()=>{\n            // Invalidate only after all operations complete\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.individuals.lists()\n            });\n        }\n    });\n    // Add a group - update store after success\n    const addGroupMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: createGroup,\n        onSuccess: (newGroup)=>{\n            // Update cache with new group to avoid refetching\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), function() {\n                let oldData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n                return [\n                    ...oldData,\n                    newGroup\n                ];\n            });\n            // Also update our Zustand store\n            storeAddGroup(newGroup);\n        },\n        onError: (err)=>{},\n        onSettled: ()=>{\n            // Invalidate only after all operations complete\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.groups.lists()\n            });\n        }\n    });\n    // Update an individual\n    const updateIndividualMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: updateIndividual,\n        onMutate: async (param)=>{\n            let { id, data } = param;\n            // Optimistic update for individual\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: travelerKeys.individuals.detail(id)\n            });\n            const previousIndividual = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(travelerKeys.individuals.detail(id));\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.individuals.detail(id), (old)=>({\n                    ...old,\n                    name: data.name,\n                    backpack: data.backpack\n                }));\n            return {\n                previousIndividual\n            };\n        },\n        onSuccess: (updatedIndividual)=>{},\n        onError: (err, variables, context)=>{\n            // Rollback to previous data on error\n            if (context === null || context === void 0 ? void 0 : context.previousIndividual) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.individuals.detail(variables.id), context.previousIndividual);\n            }\n        },\n        onSettled: (data, error, param)=>{\n            let { id } = param;\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.individuals.detail(id)\n            });\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.individuals.lists()\n            });\n        }\n    });\n    // Update a group\n    const updateGroupMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: updateGroup,\n        onSuccess: (updatedGroup)=>{\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.groups.detail(updatedGroup.id)\n            });\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.groups.lists()\n            });\n        },\n        onError: (err)=>{}\n    });\n    // Mejoremos la mutación para manejar más efectivamente la UI\n    const deleteGroupMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: deleteGroup,\n        onMutate: async (id)=>{\n            // Cancelar todas las consultas pendientes para evitar actualizaciones conflictivas\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries();\n            // Guardar el estado previo de los datos\n            const previousGroups = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(travelerKeys.groups.lists());\n            // También guardamos los datos filtrados por fecha si existen\n            const currentDate = new Date();\n            const dateKey = (0,_barrel_optimize_names_format_date_fns__WEBPACK_IMPORTED_MODULE_6__.format)(currentDate, \"yyyy-MM-dd\");\n            const previousFilteredData = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData([\n                ...travelerKeys.all,\n                {\n                    date: dateKey\n                }\n            ]);\n            // Actualización optimista en la lista principal de grupos\n            if (previousGroups) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), previousGroups.filter((group)=>group.id !== id));\n            }\n            // Actualización optimista en los datos filtrados por fecha\n            if (previousFilteredData) {\n                const updatedFilteredData = {\n                    ...previousFilteredData,\n                    groups: previousFilteredData.groups.filter((group)=>group.id !== id)\n                };\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData([\n                    ...travelerKeys.all,\n                    {\n                        date: dateKey\n                    }\n                ], updatedFilteredData);\n            }\n            // Also update our Zustand store optimistically\n            storeRemoveGroup(id);\n            return {\n                previousGroups,\n                previousFilteredData,\n                dateKey\n            };\n        },\n        onSuccess: (deletedGroup)=>{\n            // Invalidar TODAS las consultas relacionadas con grupos\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.groups.all\n            });\n            // Invalidar también las consultas que combinan grupos e individuos\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.all\n            });\n            // Eliminar específicamente la consulta de detalle del grupo\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.removeQueries({\n                queryKey: travelerKeys.groups.detail(deletedGroup.id)\n            });\n        },\n        onError: (err, id, context)=>{\n            // Restaurar todos los datos previos en caso de error\n            if (context === null || context === void 0 ? void 0 : context.previousGroups) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), context.previousGroups);\n            }\n            if (context === null || context === void 0 ? void 0 : context.previousFilteredData) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData([\n                    ...travelerKeys.all,\n                    {\n                        date: context.dateKey\n                    }\n                ], context.previousFilteredData);\n            }\n        },\n        onSettled: ()=>{\n            // Forzar una actualización completa de todas las consultas de viajeros\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.all\n            });\n        }\n    });\n    // Delete an individual\n    const deleteIndividualMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: deleteIndividual,\n        onMutate: async (id)=>{\n            // Optimistic update - remove from cache immediately\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: travelerKeys.individuals.lists()\n            });\n            const previousIndividuals = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(travelerKeys.individuals.lists());\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.individuals.lists(), function() {\n                let old = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n                return old.filter((individual)=>individual.id !== id);\n            });\n            // Also update our Zustand store optimistically\n            storeRemoveIndividual(id);\n            return {\n                previousIndividuals\n            };\n        },\n        onSuccess: (param)=>{\n            let { id } = param;\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.removeQueries({\n                queryKey: travelerKeys.individuals.detail(id)\n            });\n        },\n        onError: (err, id, context)=>{\n            // Rollback to previous data\n            if (context === null || context === void 0 ? void 0 : context.previousIndividuals) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.individuals.lists(), context.previousIndividuals);\n            }\n        },\n        onSettled: ()=>{\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.individuals.lists()\n            });\n        }\n    });\n    // Replace the addPersonToGroupMutation with this optimistic version\n    const addPersonToGroupMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: addPersonToGroup,\n        // Add optimistic updates\n        onMutate: async (param)=>{\n            let { group, personData } = param;\n            // Cancel pending queries to avoid conflicts\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: travelerKeys.groups.lists()\n            });\n            // Get current groups data\n            const previousGroups = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(travelerKeys.groups.lists());\n            // Create a temporary person object with all required fields\n            const tempPerson = {\n                id: \"temp-\".concat(Date.now()),\n                name: personData.name,\n                group_id: group.id,\n                backpack: personData.backpack || false,\n                partner_id: (selectedPartner === null || selectedPartner === void 0 ? void 0 : selectedPartner.id) || group.partner_id\n            };\n            // Update the cache optimistically\n            if (previousGroups) {\n                const updatedGroups = previousGroups.map((g)=>{\n                    if (g.id === group.id) {\n                        // Add the new person to this group and increment size\n                        return {\n                            ...g,\n                            people: [\n                                ...g.people || [],\n                                tempPerson\n                            ],\n                            size: (g.size || 0) + 1\n                        };\n                    }\n                    return g;\n                });\n                // Update both the React Query cache and Zustand store\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), updatedGroups);\n                setGroups(updatedGroups);\n            }\n            // Return previous data for potential rollback\n            return {\n                previousGroups\n            };\n        },\n        onSuccess: (result, param)=>{\n            let { group } = param;\n            // Get the returned data\n            const { newPerson, groupId, newGroupSize } = result;\n            // Get current data from cache\n            const currentGroups = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(travelerKeys.groups.lists());\n            if (currentGroups && newPerson) {\n                // Replace temp entry with real data\n                const finalGroups = currentGroups.map((g)=>{\n                    if (g.id === groupId) {\n                        return {\n                            ...g,\n                            // Remove any temporary entries and add the real person data\n                            people: [\n                                ...g.people.filter((p)=>!String(p.id).startsWith(\"temp-\")),\n                                newPerson\n                            ],\n                            size: newGroupSize\n                        };\n                    }\n                    return g;\n                });\n                // Update both cache and store\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), finalGroups);\n                setGroups(finalGroups);\n            }\n        },\n        onError: (err, variables, context)=>{\n            // Restore previous state if operation fails\n            if (context === null || context === void 0 ? void 0 : context.previousGroups) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), context.previousGroups);\n                setGroups(context.previousGroups);\n            }\n        }\n    });\n    // Mejorar la mutación para actualizar persona (backpack toggle)\n    const updatePersonMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: updatePerson,\n        onMutate: async (personData)=>{\n            // Claves para actualizar\n            const { id } = personData;\n            const individualKey = travelerKeys.individuals.lists();\n            const groupsKey = travelerKeys.groups.lists();\n            // Cancelar consultas pendientes\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: individualKey\n            });\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: groupsKey\n            });\n            // Guardar estado previo\n            const previousIndividuals = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(individualKey);\n            const previousGroups = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(groupsKey);\n            // Actualización optimista para individuales\n            if (previousIndividuals) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(individualKey, function() {\n                    let oldIndividuals = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n                    return oldIndividuals.map((ind)=>ind.id === id ? {\n                            ...ind,\n                            ...personData\n                        } : ind);\n                });\n            }\n            // Actualización optimista para miembros de grupos\n            if (previousGroups) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(groupsKey, function() {\n                    let oldGroups = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n                    return oldGroups.map((group)=>({\n                            ...group,\n                            people: (group.people || []).map((person)=>person.id === id ? {\n                                    ...person,\n                                    ...personData\n                                } : person)\n                        }));\n                });\n            }\n            return {\n                previousIndividuals,\n                previousGroups\n            };\n        },\n        onSuccess: (updatedPerson)=>{},\n        onError: (err, personData, context)=>{\n            // Restaurar estado previo en caso de error\n            if (context === null || context === void 0 ? void 0 : context.previousIndividuals) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.individuals.lists(), context.previousIndividuals);\n            }\n            if (context === null || context === void 0 ? void 0 : context.previousGroups) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), context.previousGroups);\n            }\n        },\n        onSettled: ()=>{\n            // Invalidar consultas después de la operación\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.individuals.lists()\n            });\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.groups.lists()\n            });\n        }\n    });\n    // Add this mutation after other mutations\n    const removePersonFromGroupMutation = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation)({\n        mutationFn: removePersonFromGroup,\n        onMutate: async (param)=>{\n            let { groupId, personId } = param;\n            // Cancel any outgoing queries that might affect our data\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: travelerKeys.groups.lists()\n            });\n            await _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.cancelQueries({\n                queryKey: travelerKeys.groups.detail(groupId)\n            });\n            // Snapshot all previous values we might need to restore\n            const previousGroups = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(travelerKeys.groups.lists());\n            // Find the person being removed and their group for later use\n            let removedPerson = null;\n            let currentGroup = null;\n            if (previousGroups) {\n                currentGroup = previousGroups.find((g)=>g.id === groupId);\n                if (currentGroup && currentGroup.people) {\n                    removedPerson = currentGroup.people.find((p)=>p.id === personId);\n                }\n            }\n            // Optimistically update both the cache and the Zustand store\n            if (previousGroups) {\n                // Update the React Query cache\n                const updatedGroups = previousGroups.map((group)=>{\n                    if (group.id === groupId) {\n                        // Remove the person and update the group size in one operation\n                        const filteredPeople = (group.people || []).filter((person)=>person.id !== personId);\n                        return {\n                            ...group,\n                            people: filteredPeople,\n                            size: Math.max(0, (group.size || 1) - 1)\n                        };\n                    }\n                    return group;\n                });\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), updatedGroups);\n                // Also update the Zustand store with the same changes\n                setGroups(updatedGroups);\n            }\n            // Return previous state for potential rollback\n            return {\n                previousGroups,\n                removedPerson,\n                currentGroup\n            };\n        },\n        onSuccess: (result, variables)=>{\n            // After successful DB operation, ensure UI is completely in sync\n            const { groupId, newGroupSize } = result;\n            // Update any direct references to ensure UI is consistent\n            const currentGroups = _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.getQueryData(travelerKeys.groups.lists());\n            if (currentGroups) {\n                const finalGroups = currentGroups.map((group)=>{\n                    if (group.id === groupId) {\n                        return {\n                            ...group,\n                            size: newGroupSize\n                        };\n                    }\n                    return group;\n                });\n                // Update both cache and store to ensure consistency\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), finalGroups);\n                setGroups(finalGroups);\n            }\n        },\n        onError: (err, variables, context)=>{\n            // Rollback all changes if there was an error\n            if (context === null || context === void 0 ? void 0 : context.previousGroups) {\n                _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.setQueryData(travelerKeys.groups.lists(), context.previousGroups);\n                // Also restore the store\n                setGroups(context.previousGroups);\n            }\n        },\n        onSettled: ()=>{\n            // Always refetch to ensure consistency\n            _lib_queryClient__WEBPACK_IMPORTED_MODULE_2__.queryClient.invalidateQueries({\n                queryKey: travelerKeys.groups.lists()\n            });\n        }\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>({\n            // Partners data & operations\n            partners: storePartners.length > 0 ? storePartners : partners,\n            selectedPartner,\n            selectPartner,\n            isLoadingPartners,\n            addPartner: createPartnerMutation.mutate,\n            deletePartner: deletePartnerMutation.mutate,\n            refetchPartners,\n            // Travelers data - use data from the store\n            individuals: storeIndividuals,\n            groups: storeGroups,\n            // Add this line to expose hostelAssignments from the store\n            hostelAssignments: storeHostelAssignments,\n            // Status & errors\n            isLoading,\n            error: partnersError,\n            // Rest of travelers operations (unchanged)\n            // Create a new individual\n            addIndividual: addIndividualMutation.mutate,\n            updateIndividual: updateIndividualMutation.mutate,\n            removeIndividual: deleteIndividualMutation.mutate,\n            // Groups operations\n            addGroup: addGroupMutation.mutate,\n            updateGroup: updateGroupMutation.mutate,\n            deleteGroup: deleteGroupMutation.mutate,\n            // Group membership operations\n            addPersonToGroup: addPersonToGroupMutation.mutate,\n            // convertIndividualToGroupMember:\n            //   convertIndividualToGroupMemberMutation.mutate,\n            // Update person operation\n            updatePerson: updatePersonMutation.mutate,\n            // Add this line to expose the new function\n            removePersonFromGroup: removePersonFromGroupMutation.mutate\n        }), [\n        storePartners,\n        partners,\n        selectedPartner,\n        selectPartner,\n        isLoadingPartners,\n        refetchPartners,\n        storeIndividuals,\n        storeGroups,\n        // Add this dependency\n        storeHostelAssignments,\n        isLoading,\n        // Remove individualsError and groupsError from dependencies\n        partnersError\n    ]);\n}\n_s(useTravelers, \"grn45Pi2qT/g5oPgGpOGkokc9f4=\", false, function() {\n    return [\n        _store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore,\n        _store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore,\n        _store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore,\n        _store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore,\n        _store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore,\n        _store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore,\n        _store_partnerStore__WEBPACK_IMPORTED_MODULE_3__.usePartnerStore,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__.useQuery,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation,\n        _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useMutation\n    ];\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VUcmF2ZWxlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBQ25CO0FBQ1o7QUFDRztBQUNjO0FBRU87QUFFbUI7QUFFTjtBQUU3RCxNQUFNYSxxQkFBcUIsa0JBQWtCO0FBRXBELDRCQUE0QjtBQUNyQixNQUFNQyxlQUFlO0lBQzFCQyxLQUFLO1FBQUM7S0FBWTtJQUNsQkMsT0FBTyxJQUFNO2VBQUlGLGFBQWFDLEdBQUc7WUFBRTtTQUFPO0lBQzFDRSxNQUFNLENBQUNDLFVBQVk7ZUFBSUosYUFBYUUsS0FBSztZQUFJO2dCQUFFRTtZQUFRO1NBQUU7SUFDekRDLFNBQVMsSUFBTTtlQUFJTCxhQUFhQyxHQUFHO1lBQUU7U0FBUztJQUM5Q0ssUUFBUSxDQUFDQyxLQUFPO2VBQUlQLGFBQWFLLE9BQU87WUFBSUU7U0FBRztJQUUvQyxpQ0FBaUM7SUFDakNDLGtCQUFrQixDQUFDQyxNQUFNQyxZQUFjO2VBQ2xDVixhQUFhRSxLQUFLO1lBQ3JCO2dCQUFFTztnQkFBTUM7WUFBVTtTQUNuQjtJQUVELDBCQUEwQjtJQUMxQkMsYUFBYTtRQUNYVixLQUFLO1lBQUM7U0FBYztRQUNwQkMsT0FBTyxJQUFNO21CQUFJRixhQUFhVyxXQUFXLENBQUNWLEdBQUc7Z0JBQUU7YUFBTztRQUN0REUsTUFBTSxDQUFDQyxVQUFZO21CQUFJSixhQUFhVyxXQUFXLENBQUNULEtBQUs7Z0JBQUk7b0JBQUVFO2dCQUFRO2FBQUU7UUFDckVFLFFBQVEsQ0FBQ0MsS0FBTzttQkFBSVAsYUFBYVcsV0FBVyxDQUFDVixHQUFHO2dCQUFFO2dCQUFVTTthQUFHO0lBQ2pFO0lBQ0FLLFFBQVE7UUFDTlgsS0FBSztZQUFDO1NBQVM7UUFDZkMsT0FBTyxJQUFNO21CQUFJRixhQUFhWSxNQUFNLENBQUNYLEdBQUc7Z0JBQUU7YUFBTztRQUNqREUsTUFBTSxDQUFDQyxVQUFZO21CQUFJSixhQUFhWSxNQUFNLENB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QSxnRUFBZUE7UUFDWkEsZ0VBQWVBO1FBSXRCQSxnRUFBZUE7UUFLakJBLGdFQUFlQTtRQUNWQSxnRUFBZUE7UUFTVEEsZ0VBQWVBO1FBVXhDTiwyREFBUUE7UUFxRGtCQyw4REFBV0E7UUFvQ1hBLDhEQUFXQTtRQTBTWEEsOERBQVdBO1FBc0JoQkEsOERBQVdBO1FBb0JIQSw4REFBV0E7UUF3Q2hCQSw4REFBV0E7UUFZWEEsOERBQVdBO1FBb0ZOQSw4REFBV0E7UUEwQ1hBLDhEQUFXQTtRQTRGZkEsOERBQVdBO1FBa0VGQSw4REFBV0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZVRyYXZlbGVycy5qcz81NGU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVF1ZXJ5LCB1c2VNdXRhdGlvbiB9IGZyb20gXCJAdGFuc3RhY2svcmVhY3QtcXVlcnlcIjtcclxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tIFwiLi4vbGliL3N1cGFiYXNlXCI7XHJcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSBcInNvbm5lclwiO1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tIFwiZGF0ZS1mbnNcIjtcclxuaW1wb3J0IHsgcXVlcnlDbGllbnQgfSBmcm9tIFwiQC9saWIvcXVlcnlDbGllbnRcIjtcclxuXHJcbmltcG9ydCB7IHVzZVBhcnRuZXJTdG9yZSB9IGZyb20gXCJAL3N0b3JlL3BhcnRuZXJTdG9yZVwiO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuaW1wb3J0IHsgaG9zdGVsQXNzaWdubWVudEtleXMgfSBmcm9tIFwiQC9ob29rcy91c2VIb3N0ZWxBc3NpZ25tZW50c1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNlbGVjdGVkUGFydG5lcktleSA9IFwic2VsZWN0ZWRQYXJ0bmVyXCI7XHJcblxyXG4vLyBRdWVyeSBrZXlzIHBhcmEgdHJhdmVsZXJzXHJcbmV4cG9ydCBjb25zdCB0cmF2ZWxlcktleXMgPSB7XHJcbiAgYWxsOiBbXCJ0cmF2ZWxlcnNcIl0sXHJcbiAgbGlzdHM6ICgpID0+IFsuLi50cmF2ZWxlcktleXMuYWxsLCBcImxpc3RcIl0sXHJcbiAgbGlzdDogKGZpbHRlcnMpID0+IFsuLi50cmF2ZWxlcktleXMubGlzdHMoKSwgeyBmaWx0ZXJzIH1dLFxyXG4gIGRldGFpbHM6ICgpID0+IFsuLi50cmF2ZWxlcktleXMuYWxsLCBcImRldGFpbFwiXSxcclxuICBkZXRhaWw6IChpZCkgPT4gWy4uLnRyYXZlbGVyS2V5cy5kZXRhaWxzKCksIGlkXSxcclxuXHJcbiAgLy8gRXNwZWPDrWZpY28gcG9yIGZlY2hhIHkgcGFydG5lclxyXG4gIGJ5RGF0ZUFuZFBhcnRuZXI6IChkYXRlLCBwYXJ0bmVySWQpID0+IFtcclxuICAgIC4uLnRyYXZlbGVyS2V5cy5saXN0cygpLFxyXG4gICAgeyBkYXRlLCBwYXJ0bmVySWQgfSxcclxuICBdLFxyXG5cclxuICAvLyBTcGVjaWZpYyBrZXlzIGZvciB0eXBlc1xyXG4gIGluZGl2aWR1YWxzOiB7XHJcbiAgICBhbGw6IFtcImluZGl2aWR1YWxzXCJdLFxyXG4gICAgbGlzdHM6ICgpID0+IFsuLi50cmF2ZWxlcktleXMuaW5kaXZpZHVhbHMuYWxsLCBcImxpc3RcIl0sXHJcbiAgICBsaXN0OiAoZmlsdGVycykgPT4gWy4uLnRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5saXN0cygpLCB7IGZpbHRlcnMgfV0sXHJcbiAgICBkZXRhaWw6IChpZCkgPT4gWy4uLnRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5hbGwsIFwiZGV0YWlsXCIsIGlkXSxcclxuICB9LFxyXG4gIGdyb3Vwczoge1xyXG4gICAgYWxsOiBbXCJncm91cHNcIl0sXHJcbiAgICBsaXN0czogKCkgPT4gWy4uLnRyYXZlbGVyS2V5cy5ncm91cHMuYWxsLCBcImxpc3RcIl0sXHJcbiAgICBsaXN0OiAoZmlsdGVycykgPT4gWy4uLnRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKSwgeyBmaWx0ZXJzIH1dLFxyXG4gICAgZGV0YWlsOiAoaWQpID0+IFsuLi50cmF2ZWxlcktleXMuZ3JvdXBzLmFsbCwgXCJkZXRhaWxcIiwgaWRdLFxyXG4gIH0sXHJcbn07XHJcblxyXG4vLyBDbGF2ZSBwYXJhIHBhcnRuZXJzXHJcbmV4cG9ydCBjb25zdCBwYXJ0bmVyS2V5cyA9IHtcclxuICBhbGw6IFtcInBhcnRuZXJzXCJdLFxyXG4gIGxpc3RzOiAoKSA9PiBbLi4ucGFydG5lcktleXMuYWxsLCBcImxpc3RcIl0sXHJcbiAgbGlzdDogKGZpbHRlcnMpID0+IFsuLi5wYXJ0bmVyS2V5cy5saXN0cygpLCB7IGZpbHRlcnMgfV0sXHJcbiAgYnlEYXRlOiAoZGF0ZSkgPT4gWy4uLnBhcnRuZXJLZXlzLmxpc3RzKCksIHsgZGF0ZSB9XSxcclxuICBkZXRhaWxzOiAoKSA9PiBbLi4ucGFydG5lcktleXMuYWxsLCBcImRldGFpbFwiXSxcclxuICBkZXRhaWw6IChpZCkgPT4gWy4uLnBhcnRuZXJLZXlzLmRldGFpbHMoKSwgaWRdLFxyXG4gIGFzc2lnbm1lbnRzOiAoKSA9PiBbLi4ucGFydG5lcktleXMuYWxsLCBcImFzc2lnbm1lbnRzXCJdLFxyXG4gIGFzc2lnbm1lbnRzQnlEYXRlOiAoZGF0ZSkgPT4gWy4uLnBhcnRuZXJLZXlzLmFzc2lnbm1lbnRzKCksIHsgZGF0ZSB9XSxcclxufTtcclxuXHJcbi8vIEZ1bmNpw7NuIHBhcmEgb2J0ZW5lciBwYXJ0bmVycyBzZWfDum4gbGEgZmVjaGFcclxuY29uc3QgZmV0Y2hQYXJ0bmVyc0J5RGF0ZSA9IGFzeW5jIChkYXRlKSA9PiB7XHJcbiAgY29uc3QgZGF0ZVN0ciA9IGZvcm1hdChuZXcgRGF0ZShkYXRlKSwgXCJ5eXl5LU1NLWRkXCIpO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gTW9kaWZpY2Ftb3MgbGEgY29uc3VsdGEgcGFyYSBvYnRlbmVyIHBhcnRuZXJzIGRvbmRlIGxhIGZlY2hhIHNlbGVjY2lvbmFkYSBlc3TDqSBkZW50cm8gZGVsIHJhbmdvXHJcbiAgICBjb25zdCB7IGRhdGE6IHBhcnRuZXJzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJwYXJ0bmVyc1wiKVxyXG4gICAgICAuc2VsZWN0KFwiKlwiKVxyXG4gICAgICAubHRlKFwic3RhcnRfZGF0ZVwiLCBkYXRlU3RyKSAvLyBzdGFydF9kYXRlIDw9IHNlbGVjdGVkRGF0ZVxyXG4gICAgICAuZ3RlKFwiZW5kX2RhdGVcIiwgZGF0ZVN0cikgLy8gZW5kX2RhdGUgPj0gc2VsZWN0ZWREYXRlXHJcbiAgICAgIC5vcmRlcihcIm5hbWVcIik7XHJcblxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuXHJcbiAgICAvLyBJZiBubyBwYXJ0bmVycyBmb3VuZCwgcmV0dXJuIGVtcHR5IGFycmF5XHJcbiAgICBpZiAoIXBhcnRuZXJzIHx8IHBhcnRuZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yIGVhY2ggcGFydG5lciwgZmV0Y2ggaXRzIGdyb3VwcyBhbmQgaW5kaXZpZHVhbHNcclxuICAgIGNvbnN0IHBhcnRuZXJzV2l0aFJlbGF0ZWREYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIHBhcnRuZXJzLm1hcChhc3luYyAocGFydG5lcikgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBGZXRjaCBncm91cHMgZm9yIHRoaXMgcGFydG5lclxyXG4gICAgICAgICAgY29uc3QgZ3JvdXBzID0gYXdhaXQgZmV0Y2hHcm91cHMocGFydG5lci5pZCk7XHJcblxyXG4gICAgICAgICAgLy8gRmV0Y2ggaW5kaXZpZHVhbHMgZm9yIHRoaXMgcGFydG5lclxyXG4gICAgICAgICAgY29uc3QgaW5kaXZpZHVhbHMgPSBhd2FpdCBmZXRjaEluZGl2aWR1YWxzKHBhcnRuZXIuaWQpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGhvc3RlbEFzc2lnbm1lbnRzID0gYXdhaXQgZmV0Y2hIb3N0ZWxBc3NpZ25tZW50cyhwYXJ0bmVyLmlkKTtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gcGFydG5lciB3aXRoIGl0cyByZWxhdGVkIGRhdGFcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnBhcnRuZXIsXHJcbiAgICAgICAgICAgIGdyb3VwcyxcclxuICAgICAgICAgICAgaW5kaXZpZHVhbHMsXHJcbiAgICAgICAgICAgIGhvc3RlbEFzc2lnbm1lbnRzLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgIGBFcnJvciBmZXRjaGluZyByZWxhdGVkIGRhdGEgZm9yIHBhcnRuZXIgJHtwYXJ0bmVyLmlkfTpgLFxyXG4gICAgICAgICAgICBlcnJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICAvLyBSZXR1cm4gcGFydG5lciB3aXRoIGVtcHR5IHJlbGF0ZWQgZGF0YVxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4ucGFydG5lcixcclxuICAgICAgICAgICAgZ3JvdXBzOiBbXSxcclxuICAgICAgICAgICAgaW5kaXZpZHVhbHM6IFtdLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBwYXJ0bmVyc1dpdGhSZWxhdGVkRGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHBhcnRuZXJzOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRmV0Y2ggYWxsIGluZGl2aWR1YWxzIChwZXJzb25zIHdpdGhvdXQgYSBncm91cClcclxuY29uc3QgZmV0Y2hJbmRpdmlkdWFscyA9IGFzeW5jIChwYXJ0bmVySWQpID0+IHtcclxuICBpZiAoIXBhcnRuZXJJZCkge1xyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwiTm8gcGFydG5lciBJRCBwcm92aWRlZCBmb3IgZmV0Y2hpbmcgaW5kaXZpZHVhbHMsIHJldHVybmluZyBlbXB0eSBhcnJheVwiXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgLy8gRXh0cmFjdCBJRCBpZiBwYXJ0bmVySWQgaXMgYW4gb2JqZWN0XHJcbiAgY29uc3QgYWN0dWFsUGFydG5lcklkID1cclxuICAgIHR5cGVvZiBwYXJ0bmVySWQgPT09IFwib2JqZWN0XCIgJiYgcGFydG5lcklkICE9PSBudWxsXHJcbiAgICAgID8gcGFydG5lcklkLmlkIHx8IG51bGxcclxuICAgICAgOiBwYXJ0bmVySWQ7XHJcblxyXG4gIC8vIE9ubHkgcHJvY2VlZCB3aXRoIHRoZSBxdWVyeSBpZiB3ZSBoYXZlIGEgdmFsaWQgcGFydG5lciBJRFxyXG4gIGlmICghYWN0dWFsUGFydG5lcklkKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkludmFsaWQgcGFydG5lciBJRCwgcmV0dXJuaW5nIGVtcHR5IGFycmF5XCIpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwicGVyc29uXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAgIC5pcyhcImdyb3VwX2lkXCIsIG51bGwpXHJcbiAgICAgIC5lcShcInBhcnRuZXJfaWRcIiwgYWN0dWFsUGFydG5lcklkKVxyXG4gICAgICAub3JkZXIoXCJuYW1lXCIpO1xyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xyXG5cclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcblxyXG4gICAgcmV0dXJuIGRhdGEgfHwgW107XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBpbmRpdmlkdWFsczpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZldGNoIGFsbCBncm91cHMgd2l0aCB0aGVpciBwZW9wbGVcclxuY29uc3QgZmV0Y2hHcm91cHMgPSBhc3luYyAocGFydG5lcklkKSA9PiB7XHJcbiAgaWYgKCFwYXJ0bmVySWQpIHtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIk5vIHBhcnRuZXIgSUQgcHJvdmlkZWQgZm9yIGZldGNoaW5nIGdyb3VwcywgcmV0dXJuaW5nIGVtcHR5IGFycmF5XCJcclxuICAgICk7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICAvLyBFeHRyYWN0IElEIGlmIHBhcnRuZXJJZCBpcyBhbiBvYmplY3RcclxuICBjb25zdCBhY3R1YWxQYXJ0bmVySWQgPVxyXG4gICAgdHlwZW9mIHBhcnRuZXJJZCA9PT0gXCJvYmplY3RcIiAmJiBwYXJ0bmVySWQgIT09IG51bGxcclxuICAgICAgPyBwYXJ0bmVySWQuaWQgfHwgbnVsbFxyXG4gICAgICA6IHBhcnRuZXJJZDtcclxuXHJcbiAgLy8gT25seSBwcm9jZWVkIHdpdGggdGhlIHF1ZXJ5IGlmIHdlIGhhdmUgYSB2YWxpZCBwYXJ0bmVyIElEXHJcbiAgaWYgKCFhY3R1YWxQYXJ0bmVySWQpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiSW52YWxpZCBwYXJ0bmVyIElELCByZXR1cm5pbmcgZW1wdHkgYXJyYXlcIik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJncm91cHNcIilcclxuICAgICAgLnNlbGVjdChcclxuICAgICAgICBgXHJcbiAgICAgICAgKixcclxuICAgICAgICBwZXJzb24oKilcclxuICAgICAgYFxyXG4gICAgICApXHJcbiAgICAgIC5lcShcInBhcnRuZXJfaWRcIiwgYWN0dWFsUGFydG5lcklkKTtcclxuXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG5cclxuICAgIC8vIEZvcm1hdCBkYXRhIHRvIG1hdGNoIHRoZSBvcmlnaW5hbCBzdHJ1Y3R1cmVcclxuICAgIHJldHVybiBkYXRhLm1hcCgoZ3JvdXApID0+ICh7XHJcbiAgICAgIC4uLmdyb3VwLFxyXG4gICAgICBwZW9wbGU6IGdyb3VwLnBlcnNvbiB8fCBbXSxcclxuICAgIH0pKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGdyb3VwczpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZldGNoIGhvc3RlbCBhc3NpZ25tZW50cyBmb3IgYSBzcGVjaWZpYyBwYXJ0bmVyXHJcbmNvbnN0IGZldGNoSG9zdGVsQXNzaWdubWVudHMgPSBhc3luYyAocGFydG5lcklkKSA9PiB7XHJcbiAgaWYgKCFwYXJ0bmVySWQpIHtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIk5vIHBhcnRuZXIgSUQgcHJvdmlkZWQgZm9yIGZldGNoaW5nIGhvc3RlbCBhc3NpZ25tZW50cywgcmV0dXJuaW5nIGVtcHR5IGFycmF5XCJcclxuICAgICk7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICAvLyBFeHRyYWN0IElEIGlmIHBhcnRuZXJJZCBpcyBhbiBvYmplY3RcclxuICBjb25zdCBhY3R1YWxQYXJ0bmVySWQgPVxyXG4gICAgdHlwZW9mIHBhcnRuZXJJZCA9PT0gXCJvYmplY3RcIiAmJiBwYXJ0bmVySWQgIT09IG51bGxcclxuICAgICAgPyBwYXJ0bmVySWQuaWQgfHwgbnVsbFxyXG4gICAgICA6IHBhcnRuZXJJZDtcclxuXHJcbiAgLy8gT25seSBwcm9jZWVkIHdpdGggdGhlIHF1ZXJ5IGlmIHdlIGhhdmUgYSB2YWxpZCBwYXJ0bmVyIElEXHJcbiAgaWYgKCFhY3R1YWxQYXJ0bmVySWQpIHtcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBcIkludmFsaWQgcGFydG5lciBJRCBmb3IgaG9zdGVsIGFzc2lnbm1lbnRzLCByZXR1cm5pbmcgZW1wdHkgYXJyYXlcIlxyXG4gICAgKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgY2FjaGVkIGRhdGEgaW4gdGhlIHF1ZXJ5IGNsaWVudFxyXG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHF1ZXJ5Q2xpZW50LmdldFF1ZXJ5RGF0YShcclxuICAgICAgaG9zdGVsQXNzaWdubWVudEtleXMuYnlQYXJ0bmVySWQoYWN0dWFsUGFydG5lcklkKVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoY2FjaGVkRGF0YSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGNhY2hlZCBob3N0ZWwgYXNzaWdubWVudHNcIik7XHJcbiAgICAgIHJldHVybiBjYWNoZWREYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwiaG9zdGVsX3BhcnRuZXJfYXNzaWdubWVudHNcIilcclxuICAgICAgLnNlbGVjdChcclxuICAgICAgICBgXHJcbiAgICAgICAgKixcclxuICAgICAgICBob3N0ZWw6aG9zdGVscygqKVxyXG4gICAgICBgXHJcbiAgICAgIClcclxuICAgICAgLmVxKFwicGFydG5lcl9pZFwiLCBhY3R1YWxQYXJ0bmVySWQpO1xyXG5cclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcblxyXG4gICAgLy8gU3RvcmUgdGhlIHJlc3VsdCBpbiB0aGUgcXVlcnkgY2FjaGVcclxuICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YShcclxuICAgICAgaG9zdGVsQXNzaWdubWVudEtleXMuYnlQYXJ0bmVySWQoYWN0dWFsUGFydG5lcklkKSxcclxuICAgICAgZGF0YSB8fCBbXVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gZGF0YSB8fCBbXTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGhvc3RlbCBhc3NpZ25tZW50czpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENyZWF0ZSBhIG5ldyBwYXJ0bmVyXHJcbmNvbnN0IGNyZWF0ZVBhcnRuZXIgPSBhc3luYyAocGFydG5lckRhdGEpID0+IHtcclxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgLmZyb20oXCJwYXJ0bmVyc1wiKVxyXG4gICAgLmluc2VydChbXHJcbiAgICAgIHtcclxuICAgICAgICBuYW1lOiBwYXJ0bmVyRGF0YS5uYW1lLFxyXG4gICAgICAgIHNpemU6IHBhcnRuZXJEYXRhLnNpemUgfHwgMCxcclxuICAgICAgICBkYXlzOiBwYXJ0bmVyRGF0YS5kYXlzIHx8IDUsXHJcbiAgICAgICAgc3RhcnRfZGF0ZTogcGFydG5lckRhdGEuc3RhcnRfZGF0ZSB8fCBmb3JtYXQobmV3IERhdGUoKSwgXCJ5eXl5LU1NLWRkXCIpLFxyXG4gICAgICAgIGVuZF9kYXRlOiBwYXJ0bmVyRGF0YS5lbmRfZGF0ZSB8fCBmb3JtYXQobmV3IERhdGUoKSwgXCJ5eXl5LU1NLWRkXCIpLFxyXG4gICAgICB9LFxyXG4gICAgXSlcclxuICAgIC5zZWxlY3QoKVxyXG4gICAgLnNpbmdsZSgpO1xyXG5cclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIHJldHVybiBkYXRhO1xyXG59O1xyXG5cclxuLy8gRGVsZXRlIGEgcGFydG5lclxyXG5jb25zdCBkZWxldGVQYXJ0bmVyID0gYXN5bmMgKGlkKSA9PiB7XHJcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInBhcnRuZXJzXCIpLmRlbGV0ZSgpLmVxKFwiaWRcIiwgaWQpO1xyXG5cclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG4gIHJldHVybiB7IGlkIH07XHJcbn07XHJcblxyXG4vLyBQcmUtaW5pdGlhbGl6ZSB0aGUgY2FjaGUgZm9yIHNlbGVjdGVkUGFydG5lcktleSB0byBwcmV2ZW50IHVuZGVmaW5lZCBpc3N1ZXNcclxuLy8gVGhpcyBlbnN1cmVzIHRoZSBjYWNoZSBhbHdheXMgaGFzIGEgdmFsdWUsIGV2ZW4gaWYgaXQncyBudWxsXHJcbmlmIChxdWVyeUNsaWVudC5nZXRRdWVyeURhdGEoc2VsZWN0ZWRQYXJ0bmVyS2V5KSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKHNlbGVjdGVkUGFydG5lcktleSwgbnVsbCk7XHJcbn1cclxuXHJcbi8vIEhvb2sgY29tYmluYWRvIHBhcmEgbWFuZWphciBwYXJ0bmVycyB5IHRyYXZlbGVyc1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVHJhdmVsZXJzKGluaXRpYWxEYXRlID0gbmV3IERhdGUoKSkge1xyXG4gIC8vIEVzdGFkbyBwYXJhIGxhIGZlY2hhIGFjdHVhbCAtIHVzYW1vcyBlbCBmb3JtYXRvIHN0cmluZyBwYXJhIHF1ZXJpZXNcclxuICBjb25zdCBkYXRlU3RyID0gZm9ybWF0KGluaXRpYWxEYXRlLCBcInl5eXktTU0tZGRcIik7XHJcblxyXG4gIC8vIFVzZSByZWYgZm9yIHRyYWNraW5nIHJlbmRlciBjb3VudCB0byBoZWxwIGRlYnVnIGV4Y2Vzc2l2ZSByZW5kZXJzXHJcbiAgY29uc3QgcmVuZGVyQ291bnRSZWYgPSB1c2VSZWYoMCk7XHJcbiAgcmVuZGVyQ291bnRSZWYuY3VycmVudCsrO1xyXG5cclxuICBjb25zdCB7XHJcbiAgICBwYXJ0bmVyczogc3RvcmVQYXJ0bmVycyxcclxuXHJcbiAgICBpbmRpdmlkdWFsczogc3RvcmVJbmRpdmlkdWFscyxcclxuICAgIGdyb3Vwczogc3RvcmVHcm91cHMsXHJcblxyXG4gICAgYWRkR3JvdXA6IHN0b3JlQWRkR3JvdXAsXHJcbiAgICByZW1vdmVHcm91cDogc3RvcmVSZW1vdmVHcm91cCxcclxuICAgIHVwZGF0ZUdyb3VwOiBzdG9yZVVwZGF0ZUdyb3VwLFxyXG4gICAgYWRkSW5kaXZpZHVhbDogc3RvcmVBZGRJbmRpdmlkdWFsLFxyXG4gICAgcmVtb3ZlSW5kaXZpZHVhbDogc3RvcmVSZW1vdmVJbmRpdmlkdWFsLFxyXG4gICAgdXBkYXRlSW5kaXZpZHVhbDogc3RvcmVVcGRhdGVJbmRpdmlkdWFsLFxyXG5cclxuICAgIGhvc3RlbEFzc2lnbm1lbnRzOiBzdG9yZUhvc3RlbEFzc2lnbm1lbnRzLFxyXG4gIH0gPSB1c2VQYXJ0bmVyU3RvcmUoKTtcclxuXHJcbiAgY29uc3Qgc2VsZWN0ZWRQYXJ0bmVyID0gdXNlUGFydG5lclN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuc2VsZWN0ZWRQYXJ0bmVyKTtcclxuICBjb25zdCBzZXRTZWxlY3RlZFBhcnRuZXIgPSB1c2VQYXJ0bmVyU3RvcmUoXHJcbiAgICAoc3RhdGUpID0+IHN0YXRlLnNldFNlbGVjdGVkUGFydG5lclxyXG4gICk7XHJcbiAgLy8gY29uc3QgcGFydG5lcnMgPSB1c2VQYXJ0bmVyU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5wYXJ0bmVycyk7XHJcbiAgY29uc3Qgc2V0UGFydG5lcnMgPSB1c2VQYXJ0bmVyU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5zZXRQYXJ0bmVycyk7XHJcblxyXG4gIC8vIGNvbnN0IGluZGl2aWR1YWxzID0gdXNlUGFydG5lclN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuaW5kaXZpZHVhbHMpO1xyXG4gIC8vIGNvbnN0IGdyb3VwcyA9IHVzZVBhcnRuZXJTdG9yZSgoc3RhdGUpID0+IHN0YXRlLmdyb3Vwcyk7XHJcblxyXG4gIGNvbnN0IHNldEdyb3VwcyA9IHVzZVBhcnRuZXJTdG9yZSgoc3RhdGUpID0+IHN0YXRlLnNldEdyb3Vwcyk7XHJcbiAgY29uc3Qgc2V0SW5kaXZpZHVhbHMgPSB1c2VQYXJ0bmVyU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5zZXRJbmRpdmlkdWFscyk7XHJcbiAgLy8gY29uc3QgYWRkR3JvdXAgPSB1c2VQYXJ0bmVyU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5hZGRHcm91cCk7XHJcbiAgLy8gY29uc3QgcmVtb3ZlR3JvdXAgPSB1c2VQYXJ0bmVyU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5yZW1vdmVHcm91cCk7XHJcbiAgLy8gY29uc3QgdXBkYXRlR3JvdXAgPSB1c2VQYXJ0bmVyU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS51cGRhdGVHcm91cCk7XHJcbiAgLy8gY29uc3QgYWRkSW5kaXZpZHVhbCA9IHVzZVBhcnRuZXJTdG9yZSgoc3RhdGUpID0+IHN0YXRlLmFkZEluZGl2aWR1YWwpO1xyXG4gIC8vIGNvbnN0IHJlbW92ZUluZGl2aWR1YWwgPSB1c2VQYXJ0bmVyU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5yZW1vdmVJbmRpdmlkdWFsKTtcclxuICAvLyBjb25zdCB1cGRhdGVJbmRpdmlkdWFsID0gdXNlUGFydG5lclN0b3JlKChzdGF0ZSkgPT4gc3RhdGUudXBkYXRlSW5kaXZpZHVhbCk7XHJcblxyXG4gIC8vIGNvbnN0IGhvc3RlbEFzc2lnbm1lbnRzID0gdXNlUGFydG5lclN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuaG9zdGVsQXNzaWdubWVudHMpO1xyXG4gIGNvbnN0IHNldEhvc3RlbEFzc2lnbm1lbnRzID0gdXNlUGFydG5lclN0b3JlKFxyXG4gICAgKHN0YXRlKSA9PiBzdGF0ZS5zZXRIb3N0ZWxBc3NpZ25tZW50c1xyXG4gICk7XHJcblxyXG4gIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHF1ZXJ5IHRoYXQgcnVucyB3aGVuIHRoZSBhcHAgbG9hZHNcclxuICBjb25zdCB7XHJcbiAgICBkYXRhOiBwYXJ0bmVycyA9IFtdLFxyXG4gICAgaXNMb2FkaW5nOiBpc0xvYWRpbmdQYXJ0bmVycyxcclxuICAgIGVycm9yOiBwYXJ0bmVyc0Vycm9yLFxyXG4gICAgcmVmZXRjaDogcmVmZXRjaFBhcnRuZXJzUXVlcnksXHJcbiAgfSA9IHVzZVF1ZXJ5KHtcclxuICAgIHF1ZXJ5S2V5OiBwYXJ0bmVyS2V5cy5ieURhdGUoZGF0ZVN0ciksXHJcbiAgICBxdWVyeUZuOiAoKSA9PiBmZXRjaFBhcnRuZXJzQnlEYXRlKGluaXRpYWxEYXRlKSxcclxuICAgIHN0YWxlVGltZTogNjAwMDAsIC8vIENvbnNpZGVyIGRhdGEgZnJlc2ggZm9yIDEgbWludXRlXHJcbiAgICBvblN1Y2Nlc3M6IChkYXRhKSA9PiB7XHJcbiAgICAgIC8vIFN5bmMgZmV0Y2hlZCBwYXJ0bmVycyB3aXRoIG91ciBzdG9yZVxyXG5cclxuICAgICAgc2V0UGFydG5lcnMoZGF0YSk7XHJcblxyXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgc2VsZWN0ZWQgcGFydG5lciwgdXBkYXRlIGl0cyBncm91cHMgYW5kIGluZGl2aWR1YWxzIGluIHRoZSBzdG9yZVxyXG4gICAgICBpZiAoc2VsZWN0ZWRQYXJ0bmVyPy5pZCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0bmVyID0gZGF0YS5maW5kKChwKSA9PiBwLmlkID09PSBzZWxlY3RlZFBhcnRuZXIuaWQpO1xyXG4gICAgICAgIGlmIChjdXJyZW50UGFydG5lcikge1xyXG4gICAgICAgICAgLy8gVXBkYXRlIGdyb3VwcyBhbmQgaW5kaXZpZHVhbHMgZm9yIHRoZSBzZWxlY3RlZCBwYXJ0bmVyXHJcbiAgICAgICAgICBpZiAoY3VycmVudFBhcnRuZXIuZ3JvdXBzKSBzZXRHcm91cHMoY3VycmVudFBhcnRuZXIuZ3JvdXBzKTtcclxuICAgICAgICAgIGlmIChjdXJyZW50UGFydG5lci5pbmRpdmlkdWFscylcclxuICAgICAgICAgICAgc2V0SW5kaXZpZHVhbHMoY3VycmVudFBhcnRuZXIuaW5kaXZpZHVhbHMpO1xyXG4gICAgICAgICAgLy8gQWRkIHRoaXMgbGluZSB0byB1cGRhdGUgaG9zdGVsQXNzaWdubWVudHMgaW4gdGhlIHN0b3JlXHJcbiAgICAgICAgICBpZiAoY3VycmVudFBhcnRuZXIuaG9zdGVsQXNzaWdubWVudHMpXHJcbiAgICAgICAgICAgIHNldEhvc3RlbEFzc2lnbm1lbnRzKGN1cnJlbnRQYXJ0bmVyLmhvc3RlbEFzc2lnbm1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIFJlcGxhY2UgdGhlIHNlbGVjdFBhcnRuZXIgZnVuY3Rpb24gdG8gdXNlIG91ciBzdG9yZVxyXG4gIGNvbnN0IHNlbGVjdFBhcnRuZXIgPSB1c2VDYWxsYmFjayhcclxuICAgIChwYXJ0bmVyKSA9PiB7XHJcbiAgICAgIHJldHVybiBzZXRTZWxlY3RlZFBhcnRuZXIocGFydG5lcik7XHJcbiAgICB9LFxyXG4gICAgW3NldFNlbGVjdGVkUGFydG5lcl1cclxuICApO1xyXG5cclxuICAvLyBBdXRvLXNlbGVjdCBmaXJzdCBwYXJ0bmVyIG9ubHkgaWYgbmVlZGVkIGFuZCBhdmFpbGFibGVcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHBhcnRuZXJzLmxlbmd0aCA+IDAgJiYgIXNlbGVjdGVkUGFydG5lcikge1xyXG4gICAgICAvLyBVc2UgYSBzbWFsbCBkZWxheSB0byBhdm9pZCByZW5kZXIgY3ljbGVzXHJcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHNlbGVjdFBhcnRuZXIocGFydG5lcnNbMF0pO1xyXG5cclxuICAgICAgICAvLyBBbHNvIHVwZGF0ZSBncm91cHMgYW5kIGluZGl2aWR1YWxzIGZyb20gdGhlIGZpcnN0IHBhcnRuZXJcclxuICAgICAgICBpZiAocGFydG5lcnNbMF0uZ3JvdXBzKSBzZXRHcm91cHMocGFydG5lcnNbMF0uZ3JvdXBzKTtcclxuICAgICAgICBpZiAocGFydG5lcnNbMF0uaW5kaXZpZHVhbHMpIHNldEluZGl2aWR1YWxzKHBhcnRuZXJzWzBdLmluZGl2aWR1YWxzKTtcclxuICAgICAgICAvLyBBZGQgdGhpcyBsaW5lIHRvIHVwZGF0ZSBob3N0ZWxBc3NpZ25tZW50cyBmb3IgdGhlIGZpcnN0IHBhcnRuZXJcclxuICAgICAgICBpZiAocGFydG5lcnNbMF0uaG9zdGVsQXNzaWdubWVudHMpXHJcbiAgICAgICAgICBzZXRIb3N0ZWxBc3NpZ25tZW50cyhwYXJ0bmVyc1swXS5ob3N0ZWxBc3NpZ25tZW50cyk7XHJcbiAgICAgIH0sIDUwKTtcclxuXHJcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgIH1cclxuICB9LCBbcGFydG5lcnMubGVuZ3RoLCBzZWxlY3RlZFBhcnRuZXIsIHNlbGVjdFBhcnRuZXJdKTtcclxuXHJcbiAgLy8gTXV0YXRpb25zIHBhcmEgcGFydG5lcnNcclxuICBjb25zdCBjcmVhdGVQYXJ0bmVyTXV0YXRpb24gPSB1c2VNdXRhdGlvbih7XHJcbiAgICBtdXRhdGlvbkZuOiBjcmVhdGVQYXJ0bmVyLFxyXG4gICAgb25TdWNjZXNzOiBhc3luYyAobmV3UGFydG5lcikgPT4ge1xyXG4gICAgICAvLyBJbnN0ZWFkIG9mIG1hbnVhbGx5IGFkZGluZyB0byB0aGUgYXJyYXksIHdlJ2xsOlxyXG4gICAgICAvLyAxLiBQcmVwYXJlIHRoZSBuZXcgcGFydG5lciBqdXN0IGZvciBpbml0aWFsIHNlbGVjdGlvblxyXG4gICAgICBjb25zdCBwcmVwYXJlZFBhcnRuZXIgPSB7XHJcbiAgICAgICAgLi4ubmV3UGFydG5lcixcclxuICAgICAgICBncm91cHM6IFtdLFxyXG4gICAgICAgIGluZGl2aWR1YWxzOiBbXSxcclxuICAgICAgICBob3N0ZWxBc3NpZ25tZW50czogW10sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyAyLiBJbnZhbGlkYXRlIHRoZSBxdWVyaWVzIHRvIGZvcmNlIGEgZnJlc2ggZmV0Y2hcclxuICAgICAgY29uc3QgZGF0ZVN0ciA9IGZvcm1hdChpbml0aWFsRGF0ZSwgXCJ5eXl5LU1NLWRkXCIpO1xyXG4gICAgICBhd2FpdCBxdWVyeUNsaWVudC5pbnZhbGlkYXRlUXVlcmllcyh7XHJcbiAgICAgICAgcXVlcnlLZXk6IHBhcnRuZXJLZXlzLmJ5RGF0ZShkYXRlU3RyKSxcclxuICAgICAgICByZWZldGNoQWN0aXZlOiB0cnVlLCAvLyBGb3JjZSBhbiBpbW1lZGlhdGUgcmVmZXRjaFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIDMuIFRlbXBvcmFyaWx5IHNlbGVjdCB0aGUgbmV3IHBhcnRuZXIgZm9yIFVJIHJlc3BvbnNpdmVuZXNzXHJcbiAgICAgIC8vIGJ1dCBkb24ndCBtYW51YWxseSB1cGRhdGUgdGhlIHBhcnRuZXJzIGFycmF5XHJcbiAgICAgIHNlbGVjdFBhcnRuZXIocHJlcGFyZWRQYXJ0bmVyKTtcclxuICAgICAgc2V0R3JvdXBzKFtdKTtcclxuICAgICAgc2V0SW5kaXZpZHVhbHMoW10pO1xyXG5cclxuICAgICAgLy8gNC4gRXhwbGljaXRseSByZWZldGNoIHRvIGVuc3VyZSB3ZSBoYXZlIGZyZXNoIGRhdGFcclxuICAgICAgYXdhaXQgcmVmZXRjaFBhcnRuZXJzUXVlcnkoKTtcclxuXHJcbiAgICAgIC8vIE5vdGU6IFdlJ3JlIE5PVCBtYW51YWxseSB1cGRhdGluZyB0aGUgcGFydG5lcnMgYXJyYXkgYW55bW9yZVxyXG4gICAgICAvLyBJbnN0ZWFkIGxldHRpbmcgdGhlIHF1ZXJ5IHJlZmV0Y2ggaGFuZGxlIHRoYXRcclxuICAgIH0sXHJcbiAgICBvbkVycm9yOiAoZXJyKSA9PiB7XHJcbiAgICAgIHRvYXN0LmVycm9yKGBFcnJvciBhbCBjcmVhciBwYXJ0bmVyOiAke2Vyci5tZXNzYWdlfWApO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgY29uc3QgZGVsZXRlUGFydG5lck11dGF0aW9uID0gdXNlTXV0YXRpb24oe1xyXG4gICAgbXV0YXRpb25GbjogZGVsZXRlUGFydG5lcixcclxuICAgIG9uTXV0YXRlOiBhc3luYyAoaWQpID0+IHtcclxuICAgICAgLy8gQ2FuY2VsIGFueSBvdXRnb2luZyByZWZldGNoZXMgc28gdGhleSBkb24ndCBvdmVyd3JpdGUgb3VyIG9wdGltaXN0aWMgdXBkYXRlXHJcbiAgICAgIGF3YWl0IHF1ZXJ5Q2xpZW50LmNhbmNlbFF1ZXJpZXMoeyBxdWVyeUtleTogcGFydG5lcktleXMubGlzdHMoKSB9KTtcclxuICAgICAgYXdhaXQgcXVlcnlDbGllbnQuY2FuY2VsUXVlcmllcyh7IHF1ZXJ5S2V5OiBwYXJ0bmVyS2V5cy5kZXRhaWwoaWQpIH0pO1xyXG5cclxuICAgICAgLy8gU25hcHNob3QgdGhlIHByZXZpb3VzIHZhbHVlXHJcbiAgICAgIGNvbnN0IHByZXZpb3VzUGFydG5lcnMgPSBxdWVyeUNsaWVudC5nZXRRdWVyeURhdGEocGFydG5lcktleXMubGlzdHMoKSk7XHJcblxyXG4gICAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmUgdGhlIHBhcnRuZXIgZnJvbSB0aGUgY2FjaGVcclxuICAgICAgaWYgKHByZXZpb3VzUGFydG5lcnMpIHtcclxuICAgICAgICBjb25zdCB1cGRhdGVkUGFydG5lcnMgPSBwcmV2aW91c1BhcnRuZXJzLmZpbHRlcigocCkgPT4gcC5pZCAhPT0gaWQpO1xyXG4gICAgICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YShwYXJ0bmVyS2V5cy5saXN0cygpLCB1cGRhdGVkUGFydG5lcnMpO1xyXG5cclxuICAgICAgICAvLyBBbHNvIHVwZGF0ZSB0aGUgc3RvcmVcclxuICAgICAgICBzZXRQYXJ0bmVycyh1cGRhdGVkUGFydG5lcnMpO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSdyZSBkZWxldGluZyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBhcnRuZXIsIHJlc2V0IHNlbGVjdGlvblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3RlZFBhcnRuZXIgPVxyXG4gICAgICAgICAgcXVlcnlDbGllbnQuZ2V0UXVlcnlEYXRhKHNlbGVjdGVkUGFydG5lcktleSk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3RlZFBhcnRuZXIgJiYgY3VycmVudFNlbGVjdGVkUGFydG5lci5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgIC8vIFNlbGVjdCBhIGRpZmZlcmVudCBwYXJ0bmVyIG9yIHNldCB0byBudWxsXHJcbiAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPVxyXG4gICAgICAgICAgICB1cGRhdGVkUGFydG5lcnMubGVuZ3RoID4gMCA/IHVwZGF0ZWRQYXJ0bmVyc1swXSA6IG51bGw7XHJcbiAgICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoc2VsZWN0ZWRQYXJ0bmVyS2V5LCBuZXdTZWxlY3Rpb24pO1xyXG5cclxuICAgICAgICAgIC8vIEFsc28gdXBkYXRlIGdyb3VwcyBhbmQgaW5kaXZpZHVhbHMgaWYgbmVlZGVkXHJcbiAgICAgICAgICBpZiAobmV3U2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdTZWxlY3Rpb24uZ3JvdXBzKSBzZXRHcm91cHMobmV3U2VsZWN0aW9uLmdyb3Vwcyk7XHJcbiAgICAgICAgICAgIGlmIChuZXdTZWxlY3Rpb24uaW5kaXZpZHVhbHMpXHJcbiAgICAgICAgICAgICAgc2V0SW5kaXZpZHVhbHMobmV3U2VsZWN0aW9uLmluZGl2aWR1YWxzKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNldEdyb3VwcyhbXSk7XHJcbiAgICAgICAgICAgIHNldEluZGl2aWR1YWxzKFtdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7IHByZXZpb3VzUGFydG5lcnMgfTtcclxuICAgIH0sXHJcbiAgICBvblN1Y2Nlc3M6ICh7IGlkIH0pID0+IHtcclxuICAgICAgLy8gUmVtb3ZlIGZyb20gY2FjaGUgY29tcGxldGVseVxyXG4gICAgICBxdWVyeUNsaWVudC5yZW1vdmVRdWVyaWVzKHsgcXVlcnlLZXk6IHBhcnRuZXJLZXlzLmRldGFpbChpZCkgfSk7XHJcbiAgICB9LFxyXG4gICAgb25FcnJvcjogKGVyciwgaWQsIGNvbnRleHQpID0+IHtcclxuICAgICAgdG9hc3QuZXJyb3IoYEVycm9yIGFsIGVsaW1pbmFyIHBhcnRuZXI6ICR7ZXJyLm1lc3NhZ2V9YCk7XHJcblxyXG4gICAgICAvLyBSb2xsYmFjayB0byB0aGUgcHJldmlvdXMgc3RhdGUgaWYgd2UgaGF2ZSBpdFxyXG4gICAgICBpZiAoY29udGV4dD8ucHJldmlvdXNQYXJ0bmVycykge1xyXG4gICAgICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YShwYXJ0bmVyS2V5cy5saXN0cygpLCBjb250ZXh0LnByZXZpb3VzUGFydG5lcnMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgb25TZXR0bGVkOiAoKSA9PiB7XHJcbiAgICAgIC8vIEFsd2F5cyByZWZldGNoIGFmdGVyIGVycm9yIG9yIHN1Y2Nlc3MgdG8gYmUgc3VyZSB3ZSdyZSBpbiBzeW5jIHdpdGggdGhlIHNlcnZlclxyXG4gICAgICBxdWVyeUNsaWVudC5pbnZhbGlkYXRlUXVlcmllcyh7IHF1ZXJ5S2V5OiBwYXJ0bmVyS2V5cy5saXN0cygpIH0pO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgLy8gRnVuY2nDs24gcGFyYSByZWZyZXNjYXIgbG9zIHBhcnRuZXJzIGNvbiB1bmEgbnVldmEgZmVjaGFcclxuICBjb25zdCByZWZldGNoUGFydG5lcnMgPSB1c2VDYWxsYmFjayhcclxuICAgIGFzeW5jIChkYXRlKSA9PiB7XHJcbiAgICAgIGlmIChkYXRlKSB7XHJcbiAgICAgICAgY29uc3QgbmV3RGF0ZVN0ciA9IGZvcm1hdChuZXcgRGF0ZShkYXRlKSwgXCJ5eXl5LU1NLWRkXCIpO1xyXG4gICAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHtcclxuICAgICAgICAgIHF1ZXJ5S2V5OiBwYXJ0bmVyS2V5cy5ieURhdGUobmV3RGF0ZVN0ciksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoe1xyXG4gICAgICAgICAgcXVlcnlLZXk6IHBhcnRuZXJLZXlzLmJ5RGF0ZShkYXRlU3RyKSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGF3YWl0IHJlZmV0Y2hQYXJ0bmVyc1F1ZXJ5KCk7XHJcbiAgICB9LFxyXG4gICAgW2RhdGVTdHIsIHJlZmV0Y2hQYXJ0bmVyc1F1ZXJ5XVxyXG4gICk7XHJcblxyXG4gIC8vIEluY2x1aXIgcmVzdG8gZGUgb3BlcmFjaW9uZXMgc29icmUgdHJhdmVsZXJzIGRlbCBob29rIG9yaWdpbmFsXHJcbiAgLy8gQ3JlYXRlIGEgbmV3IGluZGl2aWR1YWxcclxuICBjb25zdCBjcmVhdGVJbmRpdmlkdWFsID0gYXN5bmMgKGluZGl2aWR1YWxEYXRhKSA9PiB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcInBlcnNvblwiKVxyXG4gICAgICAuaW5zZXJ0KFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiBpbmRpdmlkdWFsRGF0YS5uYW1lLFxyXG4gICAgICAgICAgYmFja3BhY2s6IGluZGl2aWR1YWxEYXRhLmJhY2twYWNrIHx8IGZhbHNlLFxyXG4gICAgICAgICAgcGFydG5lcl9pZDogaW5kaXZpZHVhbERhdGEucGFydG5lcklkLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0pXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH07XHJcblxyXG4gIC8vIENyZWF0ZSBhIG5ldyBncm91cCB3aXRoIHBlb3BsZSBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvblxyXG4gIGNvbnN0IGNyZWF0ZUdyb3VwID0gYXN5bmMgKGdyb3VwRGF0YSkgPT4ge1xyXG4gICAgLy8gRmlyc3QgY3JlYXRlIHRoZSBncm91cFxyXG4gICAgY29uc3QgeyBwYXJ0bmVySWQgfSA9IGdyb3VwRGF0YTtcclxuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgZ3JvdXAgd2l0aCBwYXJ0bmVyIElEOlwiLCBncm91cERhdGEpO1xyXG5cclxuICAgIGNvbnN0IHsgZGF0YTogbmV3R3JvdXAsIGVycm9yOiBncm91cEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcImdyb3Vwc1wiKVxyXG4gICAgICAuaW5zZXJ0KFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBzaXplOiBncm91cERhdGEucGVvcGxlPy5sZW5ndGggfHwgMCxcclxuICAgICAgICAgIHBhcnRuZXJfaWQ6IHBhcnRuZXJJZCwgLy8gQXNpZ25hciBlbCBwYXJ0bmVyX2lkIGNvcnJlY3RhbWVudGVcclxuICAgICAgICB9LFxyXG4gICAgICBdKVxyXG4gICAgICAuc2VsZWN0KClcclxuICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgIGlmIChncm91cEVycm9yKSB0aHJvdyBncm91cEVycm9yO1xyXG5cclxuICAgIC8vIElmIHRoZXJlIGFyZSBwZW9wbGUsIGNyZWF0ZSB0aGVtXHJcbiAgICBpZiAoZ3JvdXBEYXRhLnBlb3BsZSAmJiBncm91cERhdGEucGVvcGxlLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgcGVvcGxlVG9JbnNlcnQgPSBncm91cERhdGEucGVvcGxlLm1hcCgocGVyc29uKSA9PiAoe1xyXG4gICAgICAgIG5hbWU6IHBlcnNvbi5uYW1lLFxyXG4gICAgICAgIGJhY2twYWNrOiBwZXJzb24uYmFja3BhY2sgfHwgZmFsc2UsIC8vIEFzZWd1cmFyc2UgZGUgaW5jbHVpciBlbCBlc3RhZG8gZGUgbGEgbW9jaGlsYVxyXG4gICAgICAgIGdyb3VwX2lkOiBuZXdHcm91cC5pZCxcclxuICAgICAgICBwYXJ0bmVyX2lkOiBwYXJ0bmVySWQsIC8vIEFzaWduYXIgZWwgbWlzbW8gcGFydG5lcl9pZCBhIGxvcyBtaWVtYnJvcyBkZWwgZ3J1cG9cclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgY29uc3QgeyBkYXRhOiBwZW9wbGUsIGVycm9yOiBwZW9wbGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbShcInBlcnNvblwiKVxyXG4gICAgICAgIC5pbnNlcnQocGVvcGxlVG9JbnNlcnQpXHJcbiAgICAgICAgLnNlbGVjdCgpO1xyXG5cclxuICAgICAgaWYgKHBlb3BsZUVycm9yKSB0aHJvdyBwZW9wbGVFcnJvcjtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4ubmV3R3JvdXAsXHJcbiAgICAgICAgcGVvcGxlLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLm5ld0dyb3VwLFxyXG4gICAgICBwZW9wbGU6IFtdLFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBVcGRhdGUgYW4gaW5kaXZpZHVhbFxyXG4gIGNvbnN0IHVwZGF0ZUluZGl2aWR1YWwgPSBhc3luYyAoeyBpZCwgZGF0YSB9KSA9PiB7XHJcbiAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZWREYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJwZXJzb25cIilcclxuICAgICAgLnVwZGF0ZSh7IG5hbWU6IGRhdGEubmFtZSwgYmFja3BhY2s6IGRhdGEuYmFja3BhY2sgfSlcclxuICAgICAgLmVxKFwiaWRcIiwgaWQpXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgIHJldHVybiB1cGRhdGVkRGF0YTtcclxuICB9O1xyXG5cclxuICAvLyBVcGRhdGUgYSBncm91cFxyXG4gIGNvbnN0IHVwZGF0ZUdyb3VwID0gYXN5bmMgKHsgaWQsIGRhdGEgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkR3JvdXAsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcImdyb3Vwc1wiKVxyXG4gICAgICAudXBkYXRlKHtcclxuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXHJcbiAgICAgICAgc2l6ZTogZGF0YS5zaXplIHx8IDAsXHJcbiAgICAgIH0pXHJcbiAgICAgIC5lcShcImlkXCIsIGlkKVxyXG4gICAgICAuc2VsZWN0KClcclxuICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcbiAgICByZXR1cm4gdXBkYXRlZEdyb3VwO1xyXG4gIH07XHJcbiAgY29uc3QgZGVsZXRlR3JvdXAgPSBhc3luYyAoaWQpID0+IHtcclxuICAgIC8vIFByaW1lcm8sIG9idGVuZW1vcyBsb3MgZGF0b3MgYWN0dWFsZXMgZGVsIGdydXBvIHBhcmEgdGVuZXIgZWwgY29udGV4dG8gY29tcGxldG9cclxuICAgIGNvbnN0IHsgZGF0YTogZ3JvdXBUb0RlbGV0ZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwiZ3JvdXBzXCIpXHJcbiAgICAgIC5zZWxlY3QoXCIqXCIpXHJcbiAgICAgIC5lcShcImlkXCIsIGlkKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGZldGNoRXJyb3IpIHRocm93IGZldGNoRXJyb3I7XHJcblxyXG4gICAgLy8gRWxpbWluYW1vcyBlbCBncnVwb1xyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImdyb3Vwc1wiKS5kZWxldGUoKS5lcShcImlkXCIsIGlkKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG5cclxuICAgIC8vIFJldG9ybmFtb3MgZWwgZ3J1cG8gY29tcGxldG8gcGFyYSB0ZW5lciB0b2RhIGxhIGluZm9ybWFjacOzbiBkaXNwb25pYmxlXHJcbiAgICByZXR1cm4gZ3JvdXBUb0RlbGV0ZTtcclxuICB9O1xyXG5cclxuICAvLyBEZWxldGUgYW4gaW5kaXZpZHVhbFxyXG4gIGNvbnN0IGRlbGV0ZUluZGl2aWR1YWwgPSBhc3luYyAoaWQpID0+IHtcclxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJwZXJzb25cIikuZGVsZXRlKCkuZXEoXCJpZFwiLCBpZCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxuICAgIHJldHVybiB7IGlkIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVwbGFjZSB0aGUgYWRkUGVyc29uVG9Hcm91cCBmdW5jdGlvbiB3aXRoIHRoaXMgaW1wcm92ZWQgdmVyc2lvblxyXG4gIGNvbnN0IGFkZFBlcnNvblRvR3JvdXAgPSBhc3luYyAoeyBncm91cCwgcGVyc29uRGF0YSB9KSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkFkZGluZyBwZXJzb24gdG8gZ3JvdXAgd2l0aCBJRDpcIiwgZ3JvdXAuaWQpO1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IHBhcnRuZXJfaWRcclxuICAgIGNvbnN0IHBhcnRuZXJJZCA9IHNlbGVjdGVkUGFydG5lcj8uaWQgfHwgZ3JvdXAucGFydG5lcl9pZDtcclxuXHJcbiAgICAvLyBBZGQgdGhlIHBlcnNvbiB3aXRoIGNvbXBsZXRlIGRhdGFcclxuICAgIGNvbnN0IHsgZGF0YTogbmV3UGVyc29uLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJwZXJzb25cIilcclxuICAgICAgLmluc2VydChbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbmFtZTogcGVyc29uRGF0YS5uYW1lLFxyXG4gICAgICAgICAgZ3JvdXBfaWQ6IGdyb3VwLmlkLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0pXHJcbiAgICAgIC5zZWxlY3QoKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHNpemVcclxuICAgIGNvbnN0IG5ld1NpemUgPSBncm91cC5zaXplICsgMTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKFwiZ3JvdXBzXCIpXHJcbiAgICAgICAgLnVwZGF0ZSh7IHNpemU6IG5ld1NpemUsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkgfSlcclxuICAgICAgICAuZXEoXCJpZFwiLCBncm91cC5pZClcclxuICAgICAgICAuc2VsZWN0KCk7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gY29tcGxldGUgZGF0YSBmb3IgVUkgdXBkYXRlXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV3UGVyc29uOiBuZXdQZXJzb25bMF0sXHJcbiAgICAgICAgZ3JvdXBJZDogZ3JvdXAuaWQsXHJcbiAgICAgICAgbmV3R3JvdXBTaXplOiBuZXdTaXplLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIHVwZGF0aW5nIGdyb3VwIHNpemUsIGJ1dCBwZXJzb24gd2FzIGFkZGVkOlwiLCBlcnIpO1xyXG4gICAgICAvLyBSZXR1cm4gdGhlIHBlcnNvbiBkYXRhIHNvIFVJIGNhbiBzdGlsbCB1cGRhdGVcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBuZXdQZXJzb246IG5ld1BlcnNvblswXSxcclxuICAgICAgICBncm91cElkOiBncm91cC5pZCxcclxuICAgICAgICBuZXdHcm91cFNpemU6IG5ld1NpemUsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQcOxYWRpciBsYSBmdW5jacOzbiBkZSBhY3R1YWxpemFjacOzbiBkZSBwZXJzb25hXHJcbiAgY29uc3QgdXBkYXRlUGVyc29uID0gYXN5bmMgKHBlcnNvbkRhdGEpID0+IHtcclxuICAgIGNvbnN0IHsgaWQsIC4uLnVwZGF0ZXMgfSA9IHBlcnNvbkRhdGE7XHJcbiAgICBjb25zb2xlLmxvZyhcIlVwZGF0aW5nIHBlcnNvbiBiYWNrcGFjazpcIiwgdXBkYXRlcy5iYWNrcGFjayk7XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oXCJwZXJzb25cIilcclxuICAgICAgLnVwZGF0ZSh7IGJhY2twYWNrOiB1cGRhdGVzLmJhY2twYWNrLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpIH0pXHJcbiAgICAgIC5lcShcImlkXCIsIGlkKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCB0aGlzIGZ1bmN0aW9uIGFmdGVyIG90aGVyIGRhdGFiYXNlIGZ1bmN0aW9ucyBsaWtlIGFkZFBlcnNvblRvR3JvdXBcclxuICBjb25zdCByZW1vdmVQZXJzb25Gcm9tR3JvdXAgPSBhc3luYyAoeyBncm91cElkLCBwZXJzb25JZCB9KSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlJlbW92aW5nIHBlcnNvbiBmcm9tIGdyb3VwIHdpdGggSUQ6XCIsIGdyb3VwSWQpO1xyXG5cclxuICAgIC8vIEZpcnN0LCBmZXRjaCB0aGUgY3VycmVudCBncm91cCB0byBnZXQgaXRzIHNpemVcclxuICAgIGNvbnN0IHsgZGF0YTogZ3JvdXAsIGVycm9yOiBncm91cEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcImdyb3Vwc1wiKVxyXG4gICAgICAuc2VsZWN0KFwic2l6ZSwgcGFydG5lcl9pZFwiKVxyXG4gICAgICAuZXEoXCJpZFwiLCBncm91cElkKVxyXG4gICAgICAuc2luZ2xlKCk7XHJcblxyXG4gICAgaWYgKGdyb3VwRXJyb3IpIHRocm93IGdyb3VwRXJyb3I7XHJcblxyXG4gICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkUGVyc29uLCBlcnJvcjogcGVyc29uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKFwicGVyc29uXCIpXHJcbiAgICAgIC5kZWxldGUoKVxyXG4gICAgICAuZXEoXCJpZFwiLCBwZXJzb25JZCk7XHJcblxyXG4gICAgLy8gaWYgKHBlcnNvbkVycm9yKSB0aHJvdyBwZXJzb25FcnJvcjtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgbmV3IHNpemUgYmFzZWQgb24gdGhlIGZldGNoZWQgZ3JvdXAgc2l6ZVxyXG4gICAgY29uc3QgbmV3U2l6ZSA9IE1hdGgubWF4KDAsIChncm91cD8uc2l6ZSB8fCAxKSAtIDEpO1xyXG5cclxuICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbShcImdyb3Vwc1wiKVxyXG4gICAgICAudXBkYXRlKHsgc2l6ZTogbmV3U2l6ZSB9KVxyXG4gICAgICAuZXEoXCJpZFwiLCBncm91cElkKTtcclxuXHJcbiAgICAvLyBpZiAodXBkYXRlRXJyb3IpIHRocm93IHVwZGF0ZUVycm9yO1xyXG5cclxuICAgIHJldHVybiB7IHVwZGF0ZWRQZXJzb24sIGdyb3VwSWQsIG5ld0dyb3VwU2l6ZTogbmV3U2l6ZSB9O1xyXG4gIH07XHJcblxyXG4gIC8vIERlcml2ZWQgbG9hZGluZyBhbmQgZXJyb3Igc3RhdGVzIC0gdXBkYXRlZCB0byB1c2Ugb25seSB0cmF2ZWxlcnMgcXVlcnlcclxuICBjb25zdCBpc0xvYWRpbmcgPSB1c2VNZW1vKCgpID0+IGlzTG9hZGluZ1BhcnRuZXJzLCBbaXNMb2FkaW5nUGFydG5lcnNdKTtcclxuXHJcbiAgLy8gQWRkIGFuIGluZGl2aWR1YWwgLSB1cGRhdGUgc3RvcmUgYWZ0ZXIgc3VjY2Vzc1xyXG4gIGNvbnN0IGFkZEluZGl2aWR1YWxNdXRhdGlvbiA9IHVzZU11dGF0aW9uKHtcclxuICAgIG11dGF0aW9uRm46IGNyZWF0ZUluZGl2aWR1YWwsXHJcbiAgICBvblN1Y2Nlc3M6IChuZXdJbmRpdmlkdWFsKSA9PiB7XHJcbiAgICAgIC8vIFVwZGF0ZSBjYWNoZSB3aXRoIG5ldyBpbmRpdmlkdWFsIHRvIGF2b2lkIHJlZmV0Y2hpbmdcclxuICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKFxyXG4gICAgICAgIHRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5saXN0cygpLFxyXG4gICAgICAgIChvbGREYXRhID0gW10pID0+IFsuLi5vbGREYXRhLCBuZXdJbmRpdmlkdWFsXVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQWxzbyB1cGRhdGUgb3VyIFp1c3RhbmQgc3RvcmVcclxuICAgICAgc3RvcmVBZGRJbmRpdmlkdWFsKG5ld0luZGl2aWR1YWwpO1xyXG4gICAgfSxcclxuICAgIG9uRXJyb3I6IChlcnIpID0+IHt9LFxyXG4gICAgb25TZXR0bGVkOiAoKSA9PiB7XHJcbiAgICAgIC8vIEludmFsaWRhdGUgb25seSBhZnRlciBhbGwgb3BlcmF0aW9ucyBjb21wbGV0ZVxyXG4gICAgICBxdWVyeUNsaWVudC5pbnZhbGlkYXRlUXVlcmllcyh7XHJcbiAgICAgICAgcXVlcnlLZXk6IHRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5saXN0cygpLFxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIEFkZCBhIGdyb3VwIC0gdXBkYXRlIHN0b3JlIGFmdGVyIHN1Y2Nlc3NcclxuICBjb25zdCBhZGRHcm91cE11dGF0aW9uID0gdXNlTXV0YXRpb24oe1xyXG4gICAgbXV0YXRpb25GbjogY3JlYXRlR3JvdXAsXHJcbiAgICBvblN1Y2Nlc3M6IChuZXdHcm91cCkgPT4ge1xyXG4gICAgICAvLyBVcGRhdGUgY2FjaGUgd2l0aCBuZXcgZ3JvdXAgdG8gYXZvaWQgcmVmZXRjaGluZ1xyXG4gICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEodHJhdmVsZXJLZXlzLmdyb3Vwcy5saXN0cygpLCAob2xkRGF0YSA9IFtdKSA9PiBbXHJcbiAgICAgICAgLi4ub2xkRGF0YSxcclxuICAgICAgICBuZXdHcm91cCxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICAvLyBBbHNvIHVwZGF0ZSBvdXIgWnVzdGFuZCBzdG9yZVxyXG4gICAgICBzdG9yZUFkZEdyb3VwKG5ld0dyb3VwKTtcclxuICAgIH0sXHJcbiAgICBvbkVycm9yOiAoZXJyKSA9PiB7fSxcclxuICAgIG9uU2V0dGxlZDogKCkgPT4ge1xyXG4gICAgICAvLyBJbnZhbGlkYXRlIG9ubHkgYWZ0ZXIgYWxsIG9wZXJhdGlvbnMgY29tcGxldGVcclxuICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoeyBxdWVyeUtleTogdHJhdmVsZXJLZXlzLmdyb3Vwcy5saXN0cygpIH0pO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgLy8gVXBkYXRlIGFuIGluZGl2aWR1YWxcclxuICBjb25zdCB1cGRhdGVJbmRpdmlkdWFsTXV0YXRpb24gPSB1c2VNdXRhdGlvbih7XHJcbiAgICBtdXRhdGlvbkZuOiB1cGRhdGVJbmRpdmlkdWFsLFxyXG4gICAgb25NdXRhdGU6IGFzeW5jICh7IGlkLCBkYXRhIH0pID0+IHtcclxuICAgICAgLy8gT3B0aW1pc3RpYyB1cGRhdGUgZm9yIGluZGl2aWR1YWxcclxuICAgICAgYXdhaXQgcXVlcnlDbGllbnQuY2FuY2VsUXVlcmllcyh7XHJcbiAgICAgICAgcXVlcnlLZXk6IHRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5kZXRhaWwoaWQpLFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcHJldmlvdXNJbmRpdmlkdWFsID0gcXVlcnlDbGllbnQuZ2V0UXVlcnlEYXRhKFxyXG4gICAgICAgIHRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5kZXRhaWwoaWQpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEodHJhdmVsZXJLZXlzLmluZGl2aWR1YWxzLmRldGFpbChpZCksIChvbGQpID0+ICh7XHJcbiAgICAgICAgLi4ub2xkLFxyXG4gICAgICAgIG5hbWU6IGRhdGEubmFtZSxcclxuICAgICAgICBiYWNrcGFjazogZGF0YS5iYWNrcGFjayxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgcmV0dXJuIHsgcHJldmlvdXNJbmRpdmlkdWFsIH07XHJcbiAgICB9LFxyXG4gICAgb25TdWNjZXNzOiAodXBkYXRlZEluZGl2aWR1YWwpID0+IHt9LFxyXG4gICAgb25FcnJvcjogKGVyciwgdmFyaWFibGVzLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgIC8vIFJvbGxiYWNrIHRvIHByZXZpb3VzIGRhdGEgb24gZXJyb3JcclxuICAgICAgaWYgKGNvbnRleHQ/LnByZXZpb3VzSW5kaXZpZHVhbCkge1xyXG4gICAgICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YShcclxuICAgICAgICAgIHRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5kZXRhaWwodmFyaWFibGVzLmlkKSxcclxuICAgICAgICAgIGNvbnRleHQucHJldmlvdXNJbmRpdmlkdWFsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG9uU2V0dGxlZDogKGRhdGEsIGVycm9yLCB7IGlkIH0pID0+IHtcclxuICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoe1xyXG4gICAgICAgIHF1ZXJ5S2V5OiB0cmF2ZWxlcktleXMuaW5kaXZpZHVhbHMuZGV0YWlsKGlkKSxcclxuICAgICAgfSk7XHJcbiAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHtcclxuICAgICAgICBxdWVyeUtleTogdHJhdmVsZXJLZXlzLmluZGl2aWR1YWxzLmxpc3RzKCksXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgLy8gVXBkYXRlIGEgZ3JvdXBcclxuICBjb25zdCB1cGRhdGVHcm91cE11dGF0aW9uID0gdXNlTXV0YXRpb24oe1xyXG4gICAgbXV0YXRpb25GbjogdXBkYXRlR3JvdXAsXHJcbiAgICBvblN1Y2Nlc3M6ICh1cGRhdGVkR3JvdXApID0+IHtcclxuICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoe1xyXG4gICAgICAgIHF1ZXJ5S2V5OiB0cmF2ZWxlcktleXMuZ3JvdXBzLmRldGFpbCh1cGRhdGVkR3JvdXAuaWQpLFxyXG4gICAgICB9KTtcclxuICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoeyBxdWVyeUtleTogdHJhdmVsZXJLZXlzLmdyb3Vwcy5saXN0cygpIH0pO1xyXG4gICAgfSxcclxuICAgIG9uRXJyb3I6IChlcnIpID0+IHt9LFxyXG4gIH0pO1xyXG5cclxuICAvLyBNZWpvcmVtb3MgbGEgbXV0YWNpw7NuIHBhcmEgbWFuZWphciBtw6FzIGVmZWN0aXZhbWVudGUgbGEgVUlcclxuICBjb25zdCBkZWxldGVHcm91cE11dGF0aW9uID0gdXNlTXV0YXRpb24oe1xyXG4gICAgbXV0YXRpb25GbjogZGVsZXRlR3JvdXAsXHJcbiAgICBvbk11dGF0ZTogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICAgIC8vIENhbmNlbGFyIHRvZGFzIGxhcyBjb25zdWx0YXMgcGVuZGllbnRlcyBwYXJhIGV2aXRhciBhY3R1YWxpemFjaW9uZXMgY29uZmxpY3RpdmFzXHJcbiAgICAgIGF3YWl0IHF1ZXJ5Q2xpZW50LmNhbmNlbFF1ZXJpZXMoKTtcclxuXHJcbiAgICAgIC8vIEd1YXJkYXIgZWwgZXN0YWRvIHByZXZpbyBkZSBsb3MgZGF0b3NcclxuICAgICAgY29uc3QgcHJldmlvdXNHcm91cHMgPSBxdWVyeUNsaWVudC5nZXRRdWVyeURhdGEoXHJcbiAgICAgICAgdHJhdmVsZXJLZXlzLmdyb3Vwcy5saXN0cygpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBUYW1iacOpbiBndWFyZGFtb3MgbG9zIGRhdG9zIGZpbHRyYWRvcyBwb3IgZmVjaGEgc2kgZXhpc3RlblxyXG4gICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGNvbnN0IGRhdGVLZXkgPSBmb3JtYXQoY3VycmVudERhdGUsIFwieXl5eS1NTS1kZFwiKTtcclxuICAgICAgY29uc3QgcHJldmlvdXNGaWx0ZXJlZERhdGEgPSBxdWVyeUNsaWVudC5nZXRRdWVyeURhdGEoW1xyXG4gICAgICAgIC4uLnRyYXZlbGVyS2V5cy5hbGwsXHJcbiAgICAgICAgeyBkYXRlOiBkYXRlS2V5IH0sXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgLy8gQWN0dWFsaXphY2nDs24gb3B0aW1pc3RhIGVuIGxhIGxpc3RhIHByaW5jaXBhbCBkZSBncnVwb3NcclxuICAgICAgaWYgKHByZXZpb3VzR3JvdXBzKSB7XHJcbiAgICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKFxyXG4gICAgICAgICAgdHJhdmVsZXJLZXlzLmdyb3Vwcy5saXN0cygpLFxyXG4gICAgICAgICAgcHJldmlvdXNHcm91cHMuZmlsdGVyKChncm91cCkgPT4gZ3JvdXAuaWQgIT09IGlkKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFjdHVhbGl6YWNpw7NuIG9wdGltaXN0YSBlbiBsb3MgZGF0b3MgZmlsdHJhZG9zIHBvciBmZWNoYVxyXG4gICAgICBpZiAocHJldmlvdXNGaWx0ZXJlZERhdGEpIHtcclxuICAgICAgICBjb25zdCB1cGRhdGVkRmlsdGVyZWREYXRhID0ge1xyXG4gICAgICAgICAgLi4ucHJldmlvdXNGaWx0ZXJlZERhdGEsXHJcbiAgICAgICAgICBncm91cHM6IHByZXZpb3VzRmlsdGVyZWREYXRhLmdyb3Vwcy5maWx0ZXIoXHJcbiAgICAgICAgICAgIChncm91cCkgPT4gZ3JvdXAuaWQgIT09IGlkXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKFxyXG4gICAgICAgICAgWy4uLnRyYXZlbGVyS2V5cy5hbGwsIHsgZGF0ZTogZGF0ZUtleSB9XSxcclxuICAgICAgICAgIHVwZGF0ZWRGaWx0ZXJlZERhdGFcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHNvIHVwZGF0ZSBvdXIgWnVzdGFuZCBzdG9yZSBvcHRpbWlzdGljYWxseVxyXG4gICAgICBzdG9yZVJlbW92ZUdyb3VwKGlkKTtcclxuXHJcbiAgICAgIHJldHVybiB7IHByZXZpb3VzR3JvdXBzLCBwcmV2aW91c0ZpbHRlcmVkRGF0YSwgZGF0ZUtleSB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBvblN1Y2Nlc3M6IChkZWxldGVkR3JvdXApID0+IHtcclxuICAgICAgLy8gSW52YWxpZGFyIFRPREFTIGxhcyBjb25zdWx0YXMgcmVsYWNpb25hZGFzIGNvbiBncnVwb3NcclxuICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoeyBxdWVyeUtleTogdHJhdmVsZXJLZXlzLmdyb3Vwcy5hbGwgfSk7XHJcblxyXG4gICAgICAvLyBJbnZhbGlkYXIgdGFtYmnDqW4gbGFzIGNvbnN1bHRhcyBxdWUgY29tYmluYW4gZ3J1cG9zIGUgaW5kaXZpZHVvc1xyXG4gICAgICBxdWVyeUNsaWVudC5pbnZhbGlkYXRlUXVlcmllcyh7IHF1ZXJ5S2V5OiB0cmF2ZWxlcktleXMuYWxsIH0pO1xyXG5cclxuICAgICAgLy8gRWxpbWluYXIgZXNwZWPDrWZpY2FtZW50ZSBsYSBjb25zdWx0YSBkZSBkZXRhbGxlIGRlbCBncnVwb1xyXG4gICAgICBxdWVyeUNsaWVudC5yZW1vdmVRdWVyaWVzKHtcclxuICAgICAgICBxdWVyeUtleTogdHJhdmVsZXJLZXlzLmdyb3Vwcy5kZXRhaWwoZGVsZXRlZEdyb3VwLmlkKSxcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRXJyb3I6IChlcnIsIGlkLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgIC8vIFJlc3RhdXJhciB0b2RvcyBsb3MgZGF0b3MgcHJldmlvcyBlbiBjYXNvIGRlIGVycm9yXHJcbiAgICAgIGlmIChjb250ZXh0Py5wcmV2aW91c0dyb3Vwcykge1xyXG4gICAgICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YShcclxuICAgICAgICAgIHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKSxcclxuICAgICAgICAgIGNvbnRleHQucHJldmlvdXNHcm91cHNcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29udGV4dD8ucHJldmlvdXNGaWx0ZXJlZERhdGEpIHtcclxuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoXHJcbiAgICAgICAgICBbLi4udHJhdmVsZXJLZXlzLmFsbCwgeyBkYXRlOiBjb250ZXh0LmRhdGVLZXkgfV0sXHJcbiAgICAgICAgICBjb250ZXh0LnByZXZpb3VzRmlsdGVyZWREYXRhXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvblNldHRsZWQ6ICgpID0+IHtcclxuICAgICAgLy8gRm9yemFyIHVuYSBhY3R1YWxpemFjacOzbiBjb21wbGV0YSBkZSB0b2RhcyBsYXMgY29uc3VsdGFzIGRlIHZpYWplcm9zXHJcbiAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHsgcXVlcnlLZXk6IHRyYXZlbGVyS2V5cy5hbGwgfSk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICAvLyBEZWxldGUgYW4gaW5kaXZpZHVhbFxyXG4gIGNvbnN0IGRlbGV0ZUluZGl2aWR1YWxNdXRhdGlvbiA9IHVzZU11dGF0aW9uKHtcclxuICAgIG11dGF0aW9uRm46IGRlbGV0ZUluZGl2aWR1YWwsXHJcbiAgICBvbk11dGF0ZTogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICAgIC8vIE9wdGltaXN0aWMgdXBkYXRlIC0gcmVtb3ZlIGZyb20gY2FjaGUgaW1tZWRpYXRlbHlcclxuICAgICAgYXdhaXQgcXVlcnlDbGllbnQuY2FuY2VsUXVlcmllcyh7XHJcbiAgICAgICAgcXVlcnlLZXk6IHRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5saXN0cygpLFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcHJldmlvdXNJbmRpdmlkdWFscyA9IHF1ZXJ5Q2xpZW50LmdldFF1ZXJ5RGF0YShcclxuICAgICAgICB0cmF2ZWxlcktleXMuaW5kaXZpZHVhbHMubGlzdHMoKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKHRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5saXN0cygpLCAob2xkID0gW10pID0+XHJcbiAgICAgICAgb2xkLmZpbHRlcigoaW5kaXZpZHVhbCkgPT4gaW5kaXZpZHVhbC5pZCAhPT0gaWQpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBBbHNvIHVwZGF0ZSBvdXIgWnVzdGFuZCBzdG9yZSBvcHRpbWlzdGljYWxseVxyXG4gICAgICBzdG9yZVJlbW92ZUluZGl2aWR1YWwoaWQpO1xyXG5cclxuICAgICAgcmV0dXJuIHsgcHJldmlvdXNJbmRpdmlkdWFscyB9O1xyXG4gICAgfSxcclxuICAgIG9uU3VjY2VzczogKHsgaWQgfSkgPT4ge1xyXG4gICAgICBxdWVyeUNsaWVudC5yZW1vdmVRdWVyaWVzKHtcclxuICAgICAgICBxdWVyeUtleTogdHJhdmVsZXJLZXlzLmluZGl2aWR1YWxzLmRldGFpbChpZCksXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG9uRXJyb3I6IChlcnIsIGlkLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgIC8vIFJvbGxiYWNrIHRvIHByZXZpb3VzIGRhdGFcclxuICAgICAgaWYgKGNvbnRleHQ/LnByZXZpb3VzSW5kaXZpZHVhbHMpIHtcclxuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoXHJcbiAgICAgICAgICB0cmF2ZWxlcktleXMuaW5kaXZpZHVhbHMubGlzdHMoKSxcclxuICAgICAgICAgIGNvbnRleHQucHJldmlvdXNJbmRpdmlkdWFsc1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBvblNldHRsZWQ6ICgpID0+IHtcclxuICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoe1xyXG4gICAgICAgIHF1ZXJ5S2V5OiB0cmF2ZWxlcktleXMuaW5kaXZpZHVhbHMubGlzdHMoKSxcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gIH0pO1xyXG5cclxuICAvLyBSZXBsYWNlIHRoZSBhZGRQZXJzb25Ub0dyb3VwTXV0YXRpb24gd2l0aCB0aGlzIG9wdGltaXN0aWMgdmVyc2lvblxyXG4gIGNvbnN0IGFkZFBlcnNvblRvR3JvdXBNdXRhdGlvbiA9IHVzZU11dGF0aW9uKHtcclxuICAgIG11dGF0aW9uRm46IGFkZFBlcnNvblRvR3JvdXAsXHJcblxyXG4gICAgLy8gQWRkIG9wdGltaXN0aWMgdXBkYXRlc1xyXG4gICAgb25NdXRhdGU6IGFzeW5jICh7IGdyb3VwLCBwZXJzb25EYXRhIH0pID0+IHtcclxuICAgICAgLy8gQ2FuY2VsIHBlbmRpbmcgcXVlcmllcyB0byBhdm9pZCBjb25mbGljdHNcclxuICAgICAgYXdhaXQgcXVlcnlDbGllbnQuY2FuY2VsUXVlcmllcyh7XHJcbiAgICAgICAgcXVlcnlLZXk6IHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBHZXQgY3VycmVudCBncm91cHMgZGF0YVxyXG4gICAgICBjb25zdCBwcmV2aW91c0dyb3VwcyA9IHF1ZXJ5Q2xpZW50LmdldFF1ZXJ5RGF0YShcclxuICAgICAgICB0cmF2ZWxlcktleXMuZ3JvdXBzLmxpc3RzKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBwZXJzb24gb2JqZWN0IHdpdGggYWxsIHJlcXVpcmVkIGZpZWxkc1xyXG4gICAgICBjb25zdCB0ZW1wUGVyc29uID0ge1xyXG4gICAgICAgIGlkOiBgdGVtcC0ke0RhdGUubm93KCl9YCwgLy8gVGVtcG9yYXJ5IElEIHVudGlsIHdlIGdldCB0aGUgcmVhbCBvbmVcclxuICAgICAgICBuYW1lOiBwZXJzb25EYXRhLm5hbWUsXHJcbiAgICAgICAgZ3JvdXBfaWQ6IGdyb3VwLmlkLFxyXG4gICAgICAgIGJhY2twYWNrOiBwZXJzb25EYXRhLmJhY2twYWNrIHx8IGZhbHNlLFxyXG4gICAgICAgIHBhcnRuZXJfaWQ6IHNlbGVjdGVkUGFydG5lcj8uaWQgfHwgZ3JvdXAucGFydG5lcl9pZCxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgY2FjaGUgb3B0aW1pc3RpY2FsbHlcclxuICAgICAgaWYgKHByZXZpb3VzR3JvdXBzKSB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZEdyb3VwcyA9IHByZXZpb3VzR3JvdXBzLm1hcCgoZykgPT4ge1xyXG4gICAgICAgICAgaWYgKGcuaWQgPT09IGdyb3VwLmlkKSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IHBlcnNvbiB0byB0aGlzIGdyb3VwIGFuZCBpbmNyZW1lbnQgc2l6ZVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLmcsXHJcbiAgICAgICAgICAgICAgcGVvcGxlOiBbLi4uKGcucGVvcGxlIHx8IFtdKSwgdGVtcFBlcnNvbl0sXHJcbiAgICAgICAgICAgICAgc2l6ZTogKGcuc2l6ZSB8fCAwKSArIDEsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGJvdGggdGhlIFJlYWN0IFF1ZXJ5IGNhY2hlIGFuZCBadXN0YW5kIHN0b3JlXHJcbiAgICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKSwgdXBkYXRlZEdyb3Vwcyk7XHJcbiAgICAgICAgc2V0R3JvdXBzKHVwZGF0ZWRHcm91cHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXR1cm4gcHJldmlvdXMgZGF0YSBmb3IgcG90ZW50aWFsIHJvbGxiYWNrXHJcbiAgICAgIHJldHVybiB7IHByZXZpb3VzR3JvdXBzIH07XHJcbiAgICB9LFxyXG5cclxuICAgIG9uU3VjY2VzczogKHJlc3VsdCwgeyBncm91cCB9KSA9PiB7XHJcbiAgICAgIC8vIEdldCB0aGUgcmV0dXJuZWQgZGF0YVxyXG4gICAgICBjb25zdCB7IG5ld1BlcnNvbiwgZ3JvdXBJZCwgbmV3R3JvdXBTaXplIH0gPSByZXN1bHQ7XHJcblxyXG4gICAgICAvLyBHZXQgY3VycmVudCBkYXRhIGZyb20gY2FjaGVcclxuICAgICAgY29uc3QgY3VycmVudEdyb3VwcyA9IHF1ZXJ5Q2xpZW50LmdldFF1ZXJ5RGF0YShcclxuICAgICAgICB0cmF2ZWxlcktleXMuZ3JvdXBzLmxpc3RzKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChjdXJyZW50R3JvdXBzICYmIG5ld1BlcnNvbikge1xyXG4gICAgICAgIC8vIFJlcGxhY2UgdGVtcCBlbnRyeSB3aXRoIHJlYWwgZGF0YVxyXG4gICAgICAgIGNvbnN0IGZpbmFsR3JvdXBzID0gY3VycmVudEdyb3Vwcy5tYXAoKGcpID0+IHtcclxuICAgICAgICAgIGlmIChnLmlkID09PSBncm91cElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4uZyxcclxuICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHRlbXBvcmFyeSBlbnRyaWVzIGFuZCBhZGQgdGhlIHJlYWwgcGVyc29uIGRhdGFcclxuICAgICAgICAgICAgICBwZW9wbGU6IFtcclxuICAgICAgICAgICAgICAgIC4uLmcucGVvcGxlLmZpbHRlcigocCkgPT4gIVN0cmluZyhwLmlkKS5zdGFydHNXaXRoKFwidGVtcC1cIikpLFxyXG4gICAgICAgICAgICAgICAgbmV3UGVyc29uLFxyXG4gICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgc2l6ZTogbmV3R3JvdXBTaXplLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBib3RoIGNhY2hlIGFuZCBzdG9yZVxyXG4gICAgICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YSh0cmF2ZWxlcktleXMuZ3JvdXBzLmxpc3RzKCksIGZpbmFsR3JvdXBzKTtcclxuICAgICAgICBzZXRHcm91cHMoZmluYWxHcm91cHMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRXJyb3I6IChlcnIsIHZhcmlhYmxlcywgY29udGV4dCkgPT4ge1xyXG4gICAgICAvLyBSZXN0b3JlIHByZXZpb3VzIHN0YXRlIGlmIG9wZXJhdGlvbiBmYWlsc1xyXG4gICAgICBpZiAoY29udGV4dD8ucHJldmlvdXNHcm91cHMpIHtcclxuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoXHJcbiAgICAgICAgICB0cmF2ZWxlcktleXMuZ3JvdXBzLmxpc3RzKCksXHJcbiAgICAgICAgICBjb250ZXh0LnByZXZpb3VzR3JvdXBzXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzZXRHcm91cHMoY29udGV4dC5wcmV2aW91c0dyb3Vwcyk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIC8vIE1lam9yYXIgbGEgbXV0YWNpw7NuIHBhcmEgYWN0dWFsaXphciBwZXJzb25hIChiYWNrcGFjayB0b2dnbGUpXHJcbiAgY29uc3QgdXBkYXRlUGVyc29uTXV0YXRpb24gPSB1c2VNdXRhdGlvbih7XHJcbiAgICBtdXRhdGlvbkZuOiB1cGRhdGVQZXJzb24sXHJcbiAgICBvbk11dGF0ZTogYXN5bmMgKHBlcnNvbkRhdGEpID0+IHtcclxuICAgICAgLy8gQ2xhdmVzIHBhcmEgYWN0dWFsaXphclxyXG4gICAgICBjb25zdCB7IGlkIH0gPSBwZXJzb25EYXRhO1xyXG4gICAgICBjb25zdCBpbmRpdmlkdWFsS2V5ID0gdHJhdmVsZXJLZXlzLmluZGl2aWR1YWxzLmxpc3RzKCk7XHJcbiAgICAgIGNvbnN0IGdyb3Vwc0tleSA9IHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKTtcclxuXHJcbiAgICAgIC8vIENhbmNlbGFyIGNvbnN1bHRhcyBwZW5kaWVudGVzXHJcbiAgICAgIGF3YWl0IHF1ZXJ5Q2xpZW50LmNhbmNlbFF1ZXJpZXMoeyBxdWVyeUtleTogaW5kaXZpZHVhbEtleSB9KTtcclxuICAgICAgYXdhaXQgcXVlcnlDbGllbnQuY2FuY2VsUXVlcmllcyh7IHF1ZXJ5S2V5OiBncm91cHNLZXkgfSk7XHJcblxyXG4gICAgICAvLyBHdWFyZGFyIGVzdGFkbyBwcmV2aW9cclxuICAgICAgY29uc3QgcHJldmlvdXNJbmRpdmlkdWFscyA9IHF1ZXJ5Q2xpZW50LmdldFF1ZXJ5RGF0YShpbmRpdmlkdWFsS2V5KTtcclxuICAgICAgY29uc3QgcHJldmlvdXNHcm91cHMgPSBxdWVyeUNsaWVudC5nZXRRdWVyeURhdGEoZ3JvdXBzS2V5KTtcclxuXHJcbiAgICAgIC8vIEFjdHVhbGl6YWNpw7NuIG9wdGltaXN0YSBwYXJhIGluZGl2aWR1YWxlc1xyXG4gICAgICBpZiAocHJldmlvdXNJbmRpdmlkdWFscykge1xyXG4gICAgICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YShpbmRpdmlkdWFsS2V5LCAob2xkSW5kaXZpZHVhbHMgPSBbXSkgPT5cclxuICAgICAgICAgIG9sZEluZGl2aWR1YWxzLm1hcCgoaW5kKSA9PlxyXG4gICAgICAgICAgICBpbmQuaWQgPT09IGlkID8geyAuLi5pbmQsIC4uLnBlcnNvbkRhdGEgfSA6IGluZFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFjdHVhbGl6YWNpw7NuIG9wdGltaXN0YSBwYXJhIG1pZW1icm9zIGRlIGdydXBvc1xyXG4gICAgICBpZiAocHJldmlvdXNHcm91cHMpIHtcclxuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoZ3JvdXBzS2V5LCAob2xkR3JvdXBzID0gW10pID0+XHJcbiAgICAgICAgICBvbGRHcm91cHMubWFwKChncm91cCkgPT4gKHtcclxuICAgICAgICAgICAgLi4uZ3JvdXAsXHJcbiAgICAgICAgICAgIHBlb3BsZTogKGdyb3VwLnBlb3BsZSB8fCBbXSkubWFwKChwZXJzb24pID0+XHJcbiAgICAgICAgICAgICAgcGVyc29uLmlkID09PSBpZCA/IHsgLi4ucGVyc29uLCAuLi5wZXJzb25EYXRhIH0gOiBwZXJzb25cclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgIH0pKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7IHByZXZpb3VzSW5kaXZpZHVhbHMsIHByZXZpb3VzR3JvdXBzIH07XHJcbiAgICB9LFxyXG4gICAgb25TdWNjZXNzOiAodXBkYXRlZFBlcnNvbikgPT4ge30sXHJcbiAgICBvbkVycm9yOiAoZXJyLCBwZXJzb25EYXRhLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgIC8vIFJlc3RhdXJhciBlc3RhZG8gcHJldmlvIGVuIGNhc28gZGUgZXJyb3JcclxuICAgICAgaWYgKGNvbnRleHQ/LnByZXZpb3VzSW5kaXZpZHVhbHMpIHtcclxuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoXHJcbiAgICAgICAgICB0cmF2ZWxlcktleXMuaW5kaXZpZHVhbHMubGlzdHMoKSxcclxuICAgICAgICAgIGNvbnRleHQucHJldmlvdXNJbmRpdmlkdWFsc1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjb250ZXh0Py5wcmV2aW91c0dyb3Vwcykge1xyXG4gICAgICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YShcclxuICAgICAgICAgIHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKSxcclxuICAgICAgICAgIGNvbnRleHQucHJldmlvdXNHcm91cHNcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgb25TZXR0bGVkOiAoKSA9PiB7XHJcbiAgICAgIC8vIEludmFsaWRhciBjb25zdWx0YXMgZGVzcHXDqXMgZGUgbGEgb3BlcmFjacOzblxyXG4gICAgICBxdWVyeUNsaWVudC5pbnZhbGlkYXRlUXVlcmllcyh7XHJcbiAgICAgICAgcXVlcnlLZXk6IHRyYXZlbGVyS2V5cy5pbmRpdmlkdWFscy5saXN0cygpLFxyXG4gICAgICB9KTtcclxuICAgICAgcXVlcnlDbGllbnQuaW52YWxpZGF0ZVF1ZXJpZXMoeyBxdWVyeUtleTogdHJhdmVsZXJLZXlzLmdyb3Vwcy5saXN0cygpIH0pO1xyXG4gICAgfSxcclxuICB9KTtcclxuXHJcbiAgLy8gQWRkIHRoaXMgbXV0YXRpb24gYWZ0ZXIgb3RoZXIgbXV0YXRpb25zXHJcbiAgY29uc3QgcmVtb3ZlUGVyc29uRnJvbUdyb3VwTXV0YXRpb24gPSB1c2VNdXRhdGlvbih7XHJcbiAgICBtdXRhdGlvbkZuOiByZW1vdmVQZXJzb25Gcm9tR3JvdXAsXHJcbiAgICBvbk11dGF0ZTogYXN5bmMgKHsgZ3JvdXBJZCwgcGVyc29uSWQgfSkgPT4ge1xyXG4gICAgICAvLyBDYW5jZWwgYW55IG91dGdvaW5nIHF1ZXJpZXMgdGhhdCBtaWdodCBhZmZlY3Qgb3VyIGRhdGFcclxuICAgICAgYXdhaXQgcXVlcnlDbGllbnQuY2FuY2VsUXVlcmllcyh7XHJcbiAgICAgICAgcXVlcnlLZXk6IHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKSxcclxuICAgICAgfSk7XHJcbiAgICAgIGF3YWl0IHF1ZXJ5Q2xpZW50LmNhbmNlbFF1ZXJpZXMoe1xyXG4gICAgICAgIHF1ZXJ5S2V5OiB0cmF2ZWxlcktleXMuZ3JvdXBzLmRldGFpbChncm91cElkKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBTbmFwc2hvdCBhbGwgcHJldmlvdXMgdmFsdWVzIHdlIG1pZ2h0IG5lZWQgdG8gcmVzdG9yZVxyXG4gICAgICBjb25zdCBwcmV2aW91c0dyb3VwcyA9IHF1ZXJ5Q2xpZW50LmdldFF1ZXJ5RGF0YShcclxuICAgICAgICB0cmF2ZWxlcktleXMuZ3JvdXBzLmxpc3RzKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIHBlcnNvbiBiZWluZyByZW1vdmVkIGFuZCB0aGVpciBncm91cCBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgIGxldCByZW1vdmVkUGVyc29uID0gbnVsbDtcclxuICAgICAgbGV0IGN1cnJlbnRHcm91cCA9IG51bGw7XHJcblxyXG4gICAgICBpZiAocHJldmlvdXNHcm91cHMpIHtcclxuICAgICAgICBjdXJyZW50R3JvdXAgPSBwcmV2aW91c0dyb3Vwcy5maW5kKChnKSA9PiBnLmlkID09PSBncm91cElkKTtcclxuICAgICAgICBpZiAoY3VycmVudEdyb3VwICYmIGN1cnJlbnRHcm91cC5wZW9wbGUpIHtcclxuICAgICAgICAgIHJlbW92ZWRQZXJzb24gPSBjdXJyZW50R3JvdXAucGVvcGxlLmZpbmQoKHApID0+IHAuaWQgPT09IHBlcnNvbklkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZSBib3RoIHRoZSBjYWNoZSBhbmQgdGhlIFp1c3RhbmQgc3RvcmVcclxuICAgICAgaWYgKHByZXZpb3VzR3JvdXBzKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBSZWFjdCBRdWVyeSBjYWNoZVxyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRHcm91cHMgPSBwcmV2aW91c0dyb3Vwcy5tYXAoKGdyb3VwKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZ3JvdXAuaWQgPT09IGdyb3VwSWQpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBwZXJzb24gYW5kIHVwZGF0ZSB0aGUgZ3JvdXAgc2l6ZSBpbiBvbmUgb3BlcmF0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUGVvcGxlID0gKGdyb3VwLnBlb3BsZSB8fCBbXSkuZmlsdGVyKFxyXG4gICAgICAgICAgICAgIChwZXJzb24pID0+IHBlcnNvbi5pZCAhPT0gcGVyc29uSWRcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4uZ3JvdXAsXHJcbiAgICAgICAgICAgICAgcGVvcGxlOiBmaWx0ZXJlZFBlb3BsZSxcclxuICAgICAgICAgICAgICBzaXplOiBNYXRoLm1heCgwLCAoZ3JvdXAuc2l6ZSB8fCAxKSAtIDEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEodHJhdmVsZXJLZXlzLmdyb3Vwcy5saXN0cygpLCB1cGRhdGVkR3JvdXBzKTtcclxuXHJcbiAgICAgICAgLy8gQWxzbyB1cGRhdGUgdGhlIFp1c3RhbmQgc3RvcmUgd2l0aCB0aGUgc2FtZSBjaGFuZ2VzXHJcbiAgICAgICAgc2V0R3JvdXBzKHVwZGF0ZWRHcm91cHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXR1cm4gcHJldmlvdXMgc3RhdGUgZm9yIHBvdGVudGlhbCByb2xsYmFja1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHByZXZpb3VzR3JvdXBzLFxyXG4gICAgICAgIHJlbW92ZWRQZXJzb24sXHJcbiAgICAgICAgY3VycmVudEdyb3VwLFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBvblN1Y2Nlc3M6IChyZXN1bHQsIHZhcmlhYmxlcykgPT4ge1xyXG4gICAgICAvLyBBZnRlciBzdWNjZXNzZnVsIERCIG9wZXJhdGlvbiwgZW5zdXJlIFVJIGlzIGNvbXBsZXRlbHkgaW4gc3luY1xyXG4gICAgICBjb25zdCB7IGdyb3VwSWQsIG5ld0dyb3VwU2l6ZSB9ID0gcmVzdWx0O1xyXG5cclxuICAgICAgLy8gVXBkYXRlIGFueSBkaXJlY3QgcmVmZXJlbmNlcyB0byBlbnN1cmUgVUkgaXMgY29uc2lzdGVudFxyXG4gICAgICBjb25zdCBjdXJyZW50R3JvdXBzID0gcXVlcnlDbGllbnQuZ2V0UXVlcnlEYXRhKFxyXG4gICAgICAgIHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKVxyXG4gICAgICApO1xyXG4gICAgICBpZiAoY3VycmVudEdyb3Vwcykge1xyXG4gICAgICAgIGNvbnN0IGZpbmFsR3JvdXBzID0gY3VycmVudEdyb3Vwcy5tYXAoKGdyb3VwKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZ3JvdXAuaWQgPT09IGdyb3VwSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAuLi5ncm91cCxcclxuICAgICAgICAgICAgICBzaXplOiBuZXdHcm91cFNpemUsIC8vIEVuc3VyZSBzaXplIG1hdGNoZXMgZXhhY3RseSB3aGF0IHNlcnZlciByZXR1cm5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgYm90aCBjYWNoZSBhbmQgc3RvcmUgdG8gZW5zdXJlIGNvbnNpc3RlbmN5XHJcbiAgICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKSwgZmluYWxHcm91cHMpO1xyXG4gICAgICAgIHNldEdyb3VwcyhmaW5hbEdyb3Vwcyk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgb25FcnJvcjogKGVyciwgdmFyaWFibGVzLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgIC8vIFJvbGxiYWNrIGFsbCBjaGFuZ2VzIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxyXG4gICAgICBpZiAoY29udGV4dD8ucHJldmlvdXNHcm91cHMpIHtcclxuICAgICAgICBxdWVyeUNsaWVudC5zZXRRdWVyeURhdGEoXHJcbiAgICAgICAgICB0cmF2ZWxlcktleXMuZ3JvdXBzLmxpc3RzKCksXHJcbiAgICAgICAgICBjb250ZXh0LnByZXZpb3VzR3JvdXBzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQWxzbyByZXN0b3JlIHRoZSBzdG9yZVxyXG4gICAgICAgIHNldEdyb3Vwcyhjb250ZXh0LnByZXZpb3VzR3JvdXBzKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvblNldHRsZWQ6ICgpID0+IHtcclxuICAgICAgLy8gQWx3YXlzIHJlZmV0Y2ggdG8gZW5zdXJlIGNvbnNpc3RlbmN5XHJcbiAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHsgcXVlcnlLZXk6IHRyYXZlbGVyS2V5cy5ncm91cHMubGlzdHMoKSB9KTtcclxuICAgIH0sXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB1c2VNZW1vKFxyXG4gICAgKCkgPT4gKHtcclxuICAgICAgLy8gUGFydG5lcnMgZGF0YSAmIG9wZXJhdGlvbnNcclxuICAgICAgcGFydG5lcnM6IHN0b3JlUGFydG5lcnMubGVuZ3RoID4gMCA/IHN0b3JlUGFydG5lcnMgOiBwYXJ0bmVycyxcclxuICAgICAgc2VsZWN0ZWRQYXJ0bmVyLCAvLyBUaGlzIHdpbGwgbm93IGJlIHJlYWN0aXZlIHRocm91Z2ggdGhlIFp1c3RhbmQgc3RvcmVcclxuICAgICAgc2VsZWN0UGFydG5lcixcclxuICAgICAgaXNMb2FkaW5nUGFydG5lcnMsXHJcbiAgICAgIGFkZFBhcnRuZXI6IGNyZWF0ZVBhcnRuZXJNdXRhdGlvbi5tdXRhdGUsXHJcbiAgICAgIGRlbGV0ZVBhcnRuZXI6IGRlbGV0ZVBhcnRuZXJNdXRhdGlvbi5tdXRhdGUsXHJcbiAgICAgIHJlZmV0Y2hQYXJ0bmVycywgLy8gTm93IHByb3Blcmx5IGRlZmluZWQgYWJvdmVcclxuXHJcbiAgICAgIC8vIFRyYXZlbGVycyBkYXRhIC0gdXNlIGRhdGEgZnJvbSB0aGUgc3RvcmVcclxuICAgICAgaW5kaXZpZHVhbHM6IHN0b3JlSW5kaXZpZHVhbHMsXHJcbiAgICAgIGdyb3Vwczogc3RvcmVHcm91cHMsXHJcbiAgICAgIC8vIEFkZCB0aGlzIGxpbmUgdG8gZXhwb3NlIGhvc3RlbEFzc2lnbm1lbnRzIGZyb20gdGhlIHN0b3JlXHJcbiAgICAgIGhvc3RlbEFzc2lnbm1lbnRzOiBzdG9yZUhvc3RlbEFzc2lnbm1lbnRzLFxyXG5cclxuICAgICAgLy8gU3RhdHVzICYgZXJyb3JzXHJcbiAgICAgIGlzTG9hZGluZyxcclxuICAgICAgZXJyb3I6IHBhcnRuZXJzRXJyb3IsXHJcblxyXG4gICAgICAvLyBSZXN0IG9mIHRyYXZlbGVycyBvcGVyYXRpb25zICh1bmNoYW5nZWQpXHJcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBpbmRpdmlkdWFsXHJcbiAgICAgIGFkZEluZGl2aWR1YWw6IGFkZEluZGl2aWR1YWxNdXRhdGlvbi5tdXRhdGUsXHJcbiAgICAgIHVwZGF0ZUluZGl2aWR1YWw6IHVwZGF0ZUluZGl2aWR1YWxNdXRhdGlvbi5tdXRhdGUsXHJcbiAgICAgIHJlbW92ZUluZGl2aWR1YWw6IGRlbGV0ZUluZGl2aWR1YWxNdXRhdGlvbi5tdXRhdGUsXHJcblxyXG4gICAgICAvLyBHcm91cHMgb3BlcmF0aW9uc1xyXG4gICAgICBhZGRHcm91cDogYWRkR3JvdXBNdXRhdGlvbi5tdXRhdGUsXHJcbiAgICAgIHVwZGF0ZUdyb3VwOiB1cGRhdGVHcm91cE11dGF0aW9uLm11dGF0ZSxcclxuICAgICAgZGVsZXRlR3JvdXA6IGRlbGV0ZUdyb3VwTXV0YXRpb24ubXV0YXRlLFxyXG5cclxuICAgICAgLy8gR3JvdXAgbWVtYmVyc2hpcCBvcGVyYXRpb25zXHJcbiAgICAgIGFkZFBlcnNvblRvR3JvdXA6IGFkZFBlcnNvblRvR3JvdXBNdXRhdGlvbi5tdXRhdGUsXHJcbiAgICAgIC8vIGNvbnZlcnRJbmRpdmlkdWFsVG9Hcm91cE1lbWJlcjpcclxuICAgICAgLy8gICBjb252ZXJ0SW5kaXZpZHVhbFRvR3JvdXBNZW1iZXJNdXRhdGlvbi5tdXRhdGUsXHJcblxyXG4gICAgICAvLyBVcGRhdGUgcGVyc29uIG9wZXJhdGlvblxyXG4gICAgICB1cGRhdGVQZXJzb246IHVwZGF0ZVBlcnNvbk11dGF0aW9uLm11dGF0ZSxcclxuXHJcbiAgICAgIC8vIEFkZCB0aGlzIGxpbmUgdG8gZXhwb3NlIHRoZSBuZXcgZnVuY3Rpb25cclxuICAgICAgcmVtb3ZlUGVyc29uRnJvbUdyb3VwOiByZW1vdmVQZXJzb25Gcm9tR3JvdXBNdXRhdGlvbi5tdXRhdGUsXHJcbiAgICB9KSxcclxuICAgIFtcclxuICAgICAgc3RvcmVQYXJ0bmVycyxcclxuICAgICAgcGFydG5lcnMsXHJcbiAgICAgIHNlbGVjdGVkUGFydG5lcixcclxuICAgICAgc2VsZWN0UGFydG5lcixcclxuICAgICAgaXNMb2FkaW5nUGFydG5lcnMsXHJcbiAgICAgIHJlZmV0Y2hQYXJ0bmVycyxcclxuICAgICAgc3RvcmVJbmRpdmlkdWFscyxcclxuICAgICAgc3RvcmVHcm91cHMsXHJcbiAgICAgIC8vIEFkZCB0aGlzIGRlcGVuZGVuY3lcclxuICAgICAgc3RvcmVIb3N0ZWxBc3NpZ25tZW50cyxcclxuICAgICAgaXNMb2FkaW5nLFxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGluZGl2aWR1YWxzRXJyb3IgYW5kIGdyb3Vwc0Vycm9yIGZyb20gZGVwZW5kZW5jaWVzXHJcbiAgICAgIHBhcnRuZXJzRXJyb3IsXHJcbiAgICBdXHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlUXVlcnkiLCJ1c2VNdXRhdGlvbiIsInN1cGFiYXNlIiwidG9hc3QiLCJmb3JtYXQiLCJxdWVyeUNsaWVudCIsInVzZVBhcnRuZXJTdG9yZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VNZW1vIiwiaG9zdGVsQXNzaWdubWVudEtleXMiLCJzZWxlY3RlZFBhcnRuZXJLZXkiLCJ0cmF2ZWxlcktleXMiLCJhbGwiLCJsaXN0cyIsImxpc3QiLCJmaWx0ZXJzIiwiZGV0YWlscyIsImRldGFpbCIsImlkIiwiYnlEYXRlQW5kUGFydG5lciIsImRhdGUiLCJwYXJ0bmVySWQiLCJpbmRpdmlkdWFscyIsImdyb3VwcyIsInBhcnRuZXJLZXlzIiwiYnlEYXRlIiwiYXNzaWdubWVudHMiLCJhc3NpZ25tZW50c0J5RGF0ZSIsImZldGNoUGFydG5lcnNCeURhdGUiLCJkYXRlU3RyIiwiRGF0ZSIsImRhdGEiLCJwYXJ0bmVycyIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImx0ZSIsImd0ZSIsIm9yZGVyIiwibGVuZ3RoIiwicGFydG5lcnNXaXRoUmVsYXRlZERhdGEiLCJQcm9taXNlIiwibWFwIiwicGFydG5lciIsImZldGNoR3JvdXBzIiwiZmV0Y2hJbmRpdmlkdWFscyIsImhvc3RlbEFzc2lnbm1lbnRzIiwiZmV0Y2hIb3N0ZWxBc3NpZ25tZW50cyIsImVyciIsImNvbnNvbGUiLCJsb2ciLCJhY3R1YWxQYXJ0bmVySWQiLCJxdWVyeSIsImlzIiwiZXEiLCJncm91cCIsInBlb3BsZSIsInBlcnNvbiIsImNhY2hlZERhdGEiLCJnZXRRdWVyeURhdGEiLCJieVBhcnRuZXJJZCIsInNldFF1ZXJ5RGF0YSIsImNyZWF0ZVBhcnRuZXIiLCJwYXJ0bmVyRGF0YSIsImluc2VydCIsIm5hbWUiLCJzaXplIiwiZGF5cyIsInN0YXJ0X2RhdGUiLCJlbmRfZGF0ZSIsInNpbmdsZSIsImRlbGV0ZVBhcnRuZXIiLCJkZWxldGUiLCJ1bmRlZmluZWQiLCJ1c2VUcmF2ZWxlcnMiLCJpbml0aWFsRGF0ZSIsInJlbmRlckNvdW50UmVmIiwiY3VycmVudCIsInN0b3JlUGFydG5lcnMiLCJzdG9yZUluZGl2aWR1YWxzIiwic3RvcmVHcm91cHMiLCJhZGRHcm91cCIsInN0b3JlQWRkR3JvdXAiLCJyZW1vdmVHcm91cCIsInN0b3JlUmVtb3ZlR3JvdXAiLCJ1cGRhdGVHcm91cCIsInN0b3JlVXBkYXRlR3JvdXAiLCJhZGRJbmRpdmlkdWFsIiwic3RvcmVBZGRJbmRpdmlkdWFsIiwicmVtb3ZlSW5kaXZpZHVhbCIsInN0b3JlUmVtb3ZlSW5kaXZpZHVhbCIsInVwZGF0ZUluZGl2aWR1YWwiLCJzdG9yZVVwZGF0ZUluZGl2aWR1YWwiLCJzdG9yZUhvc3RlbEFzc2lnbm1lbnRzIiwic2VsZWN0ZWRQYXJ0bmVyIiwic3RhdGUiLCJzZXRTZWxlY3RlZFBhcnRuZXIiLCJzZXRQYXJ0bmVycyIsInNldEdyb3VwcyIsInNldEluZGl2aWR1YWxzIiwic2V0SG9zdGVsQXNzaWdubWVudHMiLCJpc0xvYWRpbmciLCJpc0xvYWRpbmdQYXJ0bmVycyIsInBhcnRuZXJzRXJyb3IiLCJyZWZldGNoIiwicmVmZXRjaFBhcnRuZXJzUXVlcnkiLCJxdWVyeUtleSIsInF1ZXJ5Rm4iLCJzdGFsZVRpbWUiLCJvblN1Y2Nlc3MiLCJjdXJyZW50UGFydG5lciIsImZpbmQiLCJwIiwic2VsZWN0UGFydG5lciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjcmVhdGVQYXJ0bmVyTXV0YXRpb24iLCJtdXRhdGlvbkZuIiwibmV3UGFydG5lciIsInByZXBhcmVkUGFydG5lciIsImludmFsaWRhdGVRdWVyaWVzIiwicmVmZXRjaEFjdGl2ZSIsIm9uRXJyb3IiLCJtZXNzYWdlIiwiZGVsZXRlUGFydG5lck11dGF0aW9uIiwib25NdXRhdGUiLCJjYW5jZWxRdWVyaWVzIiwicHJldmlvdXNQYXJ0bmVycyIsInVwZGF0ZWRQYXJ0bmVycyIsImZpbHRlciIsImN1cnJlbnRTZWxlY3RlZFBhcnRuZXIiLCJuZXdTZWxlY3Rpb24iLCJyZW1vdmVRdWVyaWVzIiwiY29udGV4dCIsIm9uU2V0dGxlZCIsInJlZmV0Y2hQYXJ0bmVycyIsIm5ld0RhdGVTdHIiLCJjcmVhdGVJbmRpdmlkdWFsIiwiaW5kaXZpZHVhbERhdGEiLCJiYWNrcGFjayIsInBhcnRuZXJfaWQiLCJjcmVhdGVHcm91cCIsImdyb3VwRGF0YSIsIm5ld0dyb3VwIiwiZ3JvdXBFcnJvciIsInBlb3BsZVRvSW5zZXJ0IiwiZ3JvdXBfaWQiLCJwZW9wbGVFcnJvciIsInVwZGF0ZWREYXRhIiwidXBkYXRlIiwidXBkYXRlZEdyb3VwIiwiZGVsZXRlR3JvdXAiLCJncm91cFRvRGVsZXRlIiwiZmV0Y2hFcnJvciIsImRlbGV0ZUluZGl2aWR1YWwiLCJhZGRQZXJzb25Ub0dyb3VwIiwicGVyc29uRGF0YSIsIm5ld1BlcnNvbiIsIm5ld1NpemUiLCJ1cGRhdGVkX2F0IiwiZ3JvdXBJZCIsIm5ld0dyb3VwU2l6ZSIsIndhcm4iLCJ1cGRhdGVQZXJzb24iLCJ1cGRhdGVzIiwicmVtb3ZlUGVyc29uRnJvbUdyb3VwIiwicGVyc29uSWQiLCJ1cGRhdGVkUGVyc29uIiwicGVyc29uRXJyb3IiLCJNYXRoIiwibWF4IiwidXBkYXRlRXJyb3IiLCJhZGRJbmRpdmlkdWFsTXV0YXRpb24iLCJuZXdJbmRpdmlkdWFsIiwib2xkRGF0YSIsImFkZEdyb3VwTXV0YXRpb24iLCJ1cGRhdGVJbmRpdmlkdWFsTXV0YXRpb24iLCJwcmV2aW91c0luZGl2aWR1YWwiLCJvbGQiLCJ1cGRhdGVkSW5kaXZpZHVhbCIsInZhcmlhYmxlcyIsInVwZGF0ZUdyb3VwTXV0YXRpb24iLCJkZWxldGVHcm91cE11dGF0aW9uIiwicHJldmlvdXNHcm91cHMiLCJjdXJyZW50RGF0ZSIsImRhdGVLZXkiLCJwcmV2aW91c0ZpbHRlcmVkRGF0YSIsInVwZGF0ZWRGaWx0ZXJlZERhdGEiLCJkZWxldGVkR3JvdXAiLCJkZWxldGVJbmRpdmlkdWFsTXV0YXRpb24iLCJwcmV2aW91c0luZGl2aWR1YWxzIiwiaW5kaXZpZHVhbCIsImFkZFBlcnNvblRvR3JvdXBNdXRhdGlvbiIsInRlbXBQZXJzb24iLCJub3ciLCJ1cGRhdGVkR3JvdXBzIiwiZyIsInJlc3VsdCIsImN1cnJlbnRHcm91cHMiLCJmaW5hbEdyb3VwcyIsIlN0cmluZyIsInN0YXJ0c1dpdGgiLCJ1cGRhdGVQZXJzb25NdXRhdGlvbiIsImluZGl2aWR1YWxLZXkiLCJncm91cHNLZXkiLCJvbGRJbmRpdmlkdWFscyIsImluZCIsIm9sZEdyb3VwcyIsInJlbW92ZVBlcnNvbkZyb21Hcm91cE11dGF0aW9uIiwicmVtb3ZlZFBlcnNvbiIsImN1cnJlbnRHcm91cCIsImZpbHRlcmVkUGVvcGxlIiwiYWRkUGFydG5lciIsIm11dGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useTravelers.js\n"));

/***/ })

});